// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  academy: (where?: AcademyWhereInput) => Promise<boolean>;
  beltPromotion: (where?: BeltPromotionWhereInput) => Promise<boolean>;
  checkIn: (where?: CheckInWhereInput) => Promise<boolean>;
  classPeriod: (where?: ClassPeriodWhereInput) => Promise<boolean>;
  classSession: (where?: ClassSessionWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  instructor: (where?: InstructorWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  technique: (where?: TechniqueWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  academy: (where: AcademyWhereUniqueInput) => AcademyNullablePromise;
  academies: (args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Academy>;
  academiesConnection: (args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AcademyConnectionPromise;
  beltPromotion: (
    where: BeltPromotionWhereUniqueInput
  ) => BeltPromotionNullablePromise;
  beltPromotions: (args?: {
    where?: BeltPromotionWhereInput;
    orderBy?: BeltPromotionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BeltPromotion>;
  beltPromotionsConnection: (args?: {
    where?: BeltPromotionWhereInput;
    orderBy?: BeltPromotionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BeltPromotionConnectionPromise;
  checkIn: (where: CheckInWhereUniqueInput) => CheckInNullablePromise;
  checkIns: (args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CheckIn>;
  checkInsConnection: (args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CheckInConnectionPromise;
  classPeriod: (
    where: ClassPeriodWhereUniqueInput
  ) => ClassPeriodNullablePromise;
  classPeriods: (args?: {
    where?: ClassPeriodWhereInput;
    orderBy?: ClassPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ClassPeriod>;
  classPeriodsConnection: (args?: {
    where?: ClassPeriodWhereInput;
    orderBy?: ClassPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassPeriodConnectionPromise;
  classSession: (
    where: ClassSessionWhereUniqueInput
  ) => ClassSessionNullablePromise;
  classSessions: (args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ClassSession>;
  classSessionsConnection: (args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassSessionConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  instructor: (where: InstructorWhereUniqueInput) => InstructorNullablePromise;
  instructors: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Instructor>;
  instructorsConnection: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InstructorConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  technique: (where: TechniqueWhereUniqueInput) => TechniqueNullablePromise;
  techniques: (args?: {
    where?: TechniqueWhereInput;
    orderBy?: TechniqueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Technique>;
  techniquesConnection: (args?: {
    where?: TechniqueWhereInput;
    orderBy?: TechniqueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TechniqueConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAcademy: (data: AcademyCreateInput) => AcademyPromise;
  updateAcademy: (args: {
    data: AcademyUpdateInput;
    where: AcademyWhereUniqueInput;
  }) => AcademyPromise;
  updateManyAcademies: (args: {
    data: AcademyUpdateManyMutationInput;
    where?: AcademyWhereInput;
  }) => BatchPayloadPromise;
  upsertAcademy: (args: {
    where: AcademyWhereUniqueInput;
    create: AcademyCreateInput;
    update: AcademyUpdateInput;
  }) => AcademyPromise;
  deleteAcademy: (where: AcademyWhereUniqueInput) => AcademyPromise;
  deleteManyAcademies: (where?: AcademyWhereInput) => BatchPayloadPromise;
  createBeltPromotion: (data: BeltPromotionCreateInput) => BeltPromotionPromise;
  updateBeltPromotion: (args: {
    data: BeltPromotionUpdateInput;
    where: BeltPromotionWhereUniqueInput;
  }) => BeltPromotionPromise;
  updateManyBeltPromotions: (args: {
    data: BeltPromotionUpdateManyMutationInput;
    where?: BeltPromotionWhereInput;
  }) => BatchPayloadPromise;
  upsertBeltPromotion: (args: {
    where: BeltPromotionWhereUniqueInput;
    create: BeltPromotionCreateInput;
    update: BeltPromotionUpdateInput;
  }) => BeltPromotionPromise;
  deleteBeltPromotion: (
    where: BeltPromotionWhereUniqueInput
  ) => BeltPromotionPromise;
  deleteManyBeltPromotions: (
    where?: BeltPromotionWhereInput
  ) => BatchPayloadPromise;
  createCheckIn: (data: CheckInCreateInput) => CheckInPromise;
  updateCheckIn: (args: {
    data: CheckInUpdateInput;
    where: CheckInWhereUniqueInput;
  }) => CheckInPromise;
  updateManyCheckIns: (args: {
    data: CheckInUpdateManyMutationInput;
    where?: CheckInWhereInput;
  }) => BatchPayloadPromise;
  upsertCheckIn: (args: {
    where: CheckInWhereUniqueInput;
    create: CheckInCreateInput;
    update: CheckInUpdateInput;
  }) => CheckInPromise;
  deleteCheckIn: (where: CheckInWhereUniqueInput) => CheckInPromise;
  deleteManyCheckIns: (where?: CheckInWhereInput) => BatchPayloadPromise;
  createClassPeriod: (data: ClassPeriodCreateInput) => ClassPeriodPromise;
  updateClassPeriod: (args: {
    data: ClassPeriodUpdateInput;
    where: ClassPeriodWhereUniqueInput;
  }) => ClassPeriodPromise;
  updateManyClassPeriods: (args: {
    data: ClassPeriodUpdateManyMutationInput;
    where?: ClassPeriodWhereInput;
  }) => BatchPayloadPromise;
  upsertClassPeriod: (args: {
    where: ClassPeriodWhereUniqueInput;
    create: ClassPeriodCreateInput;
    update: ClassPeriodUpdateInput;
  }) => ClassPeriodPromise;
  deleteClassPeriod: (where: ClassPeriodWhereUniqueInput) => ClassPeriodPromise;
  deleteManyClassPeriods: (
    where?: ClassPeriodWhereInput
  ) => BatchPayloadPromise;
  createClassSession: (data: ClassSessionCreateInput) => ClassSessionPromise;
  updateClassSession: (args: {
    data: ClassSessionUpdateInput;
    where: ClassSessionWhereUniqueInput;
  }) => ClassSessionPromise;
  updateManyClassSessions: (args: {
    data: ClassSessionUpdateManyMutationInput;
    where?: ClassSessionWhereInput;
  }) => BatchPayloadPromise;
  upsertClassSession: (args: {
    where: ClassSessionWhereUniqueInput;
    create: ClassSessionCreateInput;
    update: ClassSessionUpdateInput;
  }) => ClassSessionPromise;
  deleteClassSession: (
    where: ClassSessionWhereUniqueInput
  ) => ClassSessionPromise;
  deleteManyClassSessions: (
    where?: ClassSessionWhereInput
  ) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createInstructor: (data: InstructorCreateInput) => InstructorPromise;
  updateInstructor: (args: {
    data: InstructorUpdateInput;
    where: InstructorWhereUniqueInput;
  }) => InstructorPromise;
  upsertInstructor: (args: {
    where: InstructorWhereUniqueInput;
    create: InstructorCreateInput;
    update: InstructorUpdateInput;
  }) => InstructorPromise;
  deleteInstructor: (where: InstructorWhereUniqueInput) => InstructorPromise;
  deleteManyInstructors: (where?: InstructorWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTechnique: (data: TechniqueCreateInput) => TechniquePromise;
  updateTechnique: (args: {
    data: TechniqueUpdateInput;
    where: TechniqueWhereUniqueInput;
  }) => TechniquePromise;
  updateManyTechniques: (args: {
    data: TechniqueUpdateManyMutationInput;
    where?: TechniqueWhereInput;
  }) => BatchPayloadPromise;
  upsertTechnique: (args: {
    where: TechniqueWhereUniqueInput;
    create: TechniqueCreateInput;
    update: TechniqueUpdateInput;
  }) => TechniquePromise;
  deleteTechnique: (where: TechniqueWhereUniqueInput) => TechniquePromise;
  deleteManyTechniques: (where?: TechniqueWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  academy: (
    where?: AcademySubscriptionWhereInput
  ) => AcademySubscriptionPayloadSubscription;
  beltPromotion: (
    where?: BeltPromotionSubscriptionWhereInput
  ) => BeltPromotionSubscriptionPayloadSubscription;
  checkIn: (
    where?: CheckInSubscriptionWhereInput
  ) => CheckInSubscriptionPayloadSubscription;
  classPeriod: (
    where?: ClassPeriodSubscriptionWhereInput
  ) => ClassPeriodSubscriptionPayloadSubscription;
  classSession: (
    where?: ClassSessionSubscriptionWhereInput
  ) => ClassSessionSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  instructor: (
    where?: InstructorSubscriptionWhereInput
  ) => InstructorSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  technique: (
    where?: TechniqueSubscriptionWhereInput
  ) => TechniqueSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PositionType = "STUDENT" | "INSTRUCTOR" | "ADMIN";

export type BeltColor = "WHITE" | "BLUE" | "PURPLE" | "BROWN" | "BLACK";

export type PromotionType = "BELT" | "STRIPE";

export type ClassSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BeltPromotionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "note_ASC"
  | "note_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updateAt_ASC"
  | "updateAt_DESC";

export type AcademyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CheckInOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "checked_ASC"
  | "checked_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type TechniqueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "joinDate_ASC"
  | "joinDate_DESC"
  | "position_ASC"
  | "position_DESC"
  | "beltColor_ASC"
  | "beltColor_DESC"
  | "stripeCount_ASC"
  | "stripeCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassPeriodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "eventImage_ASC"
  | "eventImage_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "date_ASC"
  | "date_DESC"
  | "type_ASC"
  | "type_DESC"
  | "price_ASC"
  | "price_DESC"
  | "location_ASC"
  | "location_DESC"
  | "note_ASC"
  | "note_DESC"
  | "publish_ASC"
  | "publish_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InstructorOrderByInput = "id_ASC" | "id_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AcademyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ClassSessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  instructor?: Maybe<InstructorWhereInput>;
  classPeriod?: Maybe<ClassPeriodWhereInput>;
  academy?: Maybe<AcademyWhereInput>;
  techniques_every?: Maybe<TechniqueWhereInput>;
  techniques_some?: Maybe<TechniqueWhereInput>;
  techniques_none?: Maybe<TechniqueWhereInput>;
  checkIns_every?: Maybe<CheckInWhereInput>;
  checkIns_some?: Maybe<CheckInWhereInput>;
  checkIns_none?: Maybe<CheckInWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassSessionWhereInput[] | ClassSessionWhereInput>;
  OR?: Maybe<ClassSessionWhereInput[] | ClassSessionWhereInput>;
  NOT?: Maybe<ClassSessionWhereInput[] | ClassSessionWhereInput>;
}

export interface InstructorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<InstructorWhereInput[] | InstructorWhereInput>;
  OR?: Maybe<InstructorWhereInput[] | InstructorWhereInput>;
  NOT?: Maybe<InstructorWhereInput[] | InstructorWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  dob?: Maybe<String>;
  dob_not?: Maybe<String>;
  dob_in?: Maybe<String[] | String>;
  dob_not_in?: Maybe<String[] | String>;
  dob_lt?: Maybe<String>;
  dob_lte?: Maybe<String>;
  dob_gt?: Maybe<String>;
  dob_gte?: Maybe<String>;
  dob_contains?: Maybe<String>;
  dob_not_contains?: Maybe<String>;
  dob_starts_with?: Maybe<String>;
  dob_not_starts_with?: Maybe<String>;
  dob_ends_with?: Maybe<String>;
  dob_not_ends_with?: Maybe<String>;
  joinDate?: Maybe<String>;
  joinDate_not?: Maybe<String>;
  joinDate_in?: Maybe<String[] | String>;
  joinDate_not_in?: Maybe<String[] | String>;
  joinDate_lt?: Maybe<String>;
  joinDate_lte?: Maybe<String>;
  joinDate_gt?: Maybe<String>;
  joinDate_gte?: Maybe<String>;
  joinDate_contains?: Maybe<String>;
  joinDate_not_contains?: Maybe<String>;
  joinDate_starts_with?: Maybe<String>;
  joinDate_not_starts_with?: Maybe<String>;
  joinDate_ends_with?: Maybe<String>;
  joinDate_not_ends_with?: Maybe<String>;
  position?: Maybe<PositionType>;
  position_not?: Maybe<PositionType>;
  position_in?: Maybe<PositionType[] | PositionType>;
  position_not_in?: Maybe<PositionType[] | PositionType>;
  beltColor?: Maybe<BeltColor>;
  beltColor_not?: Maybe<BeltColor>;
  beltColor_in?: Maybe<BeltColor[] | BeltColor>;
  beltColor_not_in?: Maybe<BeltColor[] | BeltColor>;
  stripeCount?: Maybe<Int>;
  stripeCount_not?: Maybe<Int>;
  stripeCount_in?: Maybe<Int[] | Int>;
  stripeCount_not_in?: Maybe<Int[] | Int>;
  stripeCount_lt?: Maybe<Int>;
  stripeCount_lte?: Maybe<Int>;
  stripeCount_gt?: Maybe<Int>;
  stripeCount_gte?: Maybe<Int>;
  beltPromotions_every?: Maybe<BeltPromotionWhereInput>;
  beltPromotions_some?: Maybe<BeltPromotionWhereInput>;
  beltPromotions_none?: Maybe<BeltPromotionWhereInput>;
  academies_every?: Maybe<AcademyWhereInput>;
  academies_some?: Maybe<AcademyWhereInput>;
  academies_none?: Maybe<AcademyWhereInput>;
  checkIns_every?: Maybe<CheckInWhereInput>;
  checkIns_some?: Maybe<CheckInWhereInput>;
  checkIns_none?: Maybe<CheckInWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface BeltPromotionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  category?: Maybe<PromotionType>;
  category_not?: Maybe<PromotionType>;
  category_in?: Maybe<PromotionType[] | PromotionType>;
  category_not_in?: Maybe<PromotionType[] | PromotionType>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updateAt?: Maybe<DateTimeInput>;
  updateAt_not?: Maybe<DateTimeInput>;
  updateAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateAt_lt?: Maybe<DateTimeInput>;
  updateAt_lte?: Maybe<DateTimeInput>;
  updateAt_gt?: Maybe<DateTimeInput>;
  updateAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<BeltPromotionWhereInput[] | BeltPromotionWhereInput>;
  OR?: Maybe<BeltPromotionWhereInput[] | BeltPromotionWhereInput>;
  NOT?: Maybe<BeltPromotionWhereInput[] | BeltPromotionWhereInput>;
}

export interface AcademyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  classes_every?: Maybe<ClassSessionWhereInput>;
  classes_some?: Maybe<ClassSessionWhereInput>;
  classes_none?: Maybe<ClassSessionWhereInput>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  classPeriods_every?: Maybe<ClassPeriodWhereInput>;
  classPeriods_some?: Maybe<ClassPeriodWhereInput>;
  classPeriods_none?: Maybe<ClassPeriodWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AcademyWhereInput[] | AcademyWhereInput>;
  OR?: Maybe<AcademyWhereInput[] | AcademyWhereInput>;
  NOT?: Maybe<AcademyWhereInput[] | AcademyWhereInput>;
}

export interface ClassPeriodWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  instructor?: Maybe<InstructorWhereInput>;
  classSessions_every?: Maybe<ClassSessionWhereInput>;
  classSessions_some?: Maybe<ClassSessionWhereInput>;
  classSessions_none?: Maybe<ClassSessionWhereInput>;
  academy?: Maybe<AcademyWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassPeriodWhereInput[] | ClassPeriodWhereInput>;
  OR?: Maybe<ClassPeriodWhereInput[] | ClassPeriodWhereInput>;
  NOT?: Maybe<ClassPeriodWhereInput[] | ClassPeriodWhereInput>;
}

export interface CheckInWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  checked?: Maybe<Boolean>;
  checked_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  classSession?: Maybe<ClassSessionWhereInput>;
  event?: Maybe<EventWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CheckInWhereInput[] | CheckInWhereInput>;
  OR?: Maybe<CheckInWhereInput[] | CheckInWhereInput>;
  NOT?: Maybe<CheckInWhereInput[] | CheckInWhereInput>;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  eventImage?: Maybe<String>;
  eventImage_not?: Maybe<String>;
  eventImage_in?: Maybe<String[] | String>;
  eventImage_not_in?: Maybe<String[] | String>;
  eventImage_lt?: Maybe<String>;
  eventImage_lte?: Maybe<String>;
  eventImage_gt?: Maybe<String>;
  eventImage_gte?: Maybe<String>;
  eventImage_contains?: Maybe<String>;
  eventImage_not_contains?: Maybe<String>;
  eventImage_starts_with?: Maybe<String>;
  eventImage_not_starts_with?: Maybe<String>;
  eventImage_ends_with?: Maybe<String>;
  eventImage_not_ends_with?: Maybe<String>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  price?: Maybe<String>;
  price_not?: Maybe<String>;
  price_in?: Maybe<String[] | String>;
  price_not_in?: Maybe<String[] | String>;
  price_lt?: Maybe<String>;
  price_lte?: Maybe<String>;
  price_gt?: Maybe<String>;
  price_gte?: Maybe<String>;
  price_contains?: Maybe<String>;
  price_not_contains?: Maybe<String>;
  price_starts_with?: Maybe<String>;
  price_not_starts_with?: Maybe<String>;
  price_ends_with?: Maybe<String>;
  price_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  publish?: Maybe<Boolean>;
  publish_not?: Maybe<Boolean>;
  checkIns_every?: Maybe<CheckInWhereInput>;
  checkIns_some?: Maybe<CheckInWhereInput>;
  checkIns_none?: Maybe<CheckInWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface TechniqueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TechniqueWhereInput[] | TechniqueWhereInput>;
  OR?: Maybe<TechniqueWhereInput[] | TechniqueWhereInput>;
  NOT?: Maybe<TechniqueWhereInput[] | TechniqueWhereInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  technique?: Maybe<TechniqueWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export type BeltPromotionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CheckInWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ClassPeriodWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ClassSessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type InstructorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TechniqueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface AcademyCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  classes?: Maybe<ClassSessionCreateManyWithoutAcademyInput>;
  users?: Maybe<UserCreateManyWithoutAcademiesInput>;
  classPeriods?: Maybe<ClassPeriodCreateManyWithoutAcademyInput>;
}

export interface ClassSessionCreateManyWithoutAcademyInput {
  create?: Maybe<
    | ClassSessionCreateWithoutAcademyInput[]
    | ClassSessionCreateWithoutAcademyInput
  >;
  connect?: Maybe<
    ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput
  >;
}

export interface ClassSessionCreateWithoutAcademyInput {
  id?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  instructor: InstructorCreateOneInput;
  classPeriod: ClassPeriodCreateOneWithoutClassSessionsInput;
  techniques?: Maybe<TechniqueCreateManyInput>;
  checkIns?: Maybe<CheckInCreateManyWithoutClassSessionInput>;
}

export interface InstructorCreateOneInput {
  create?: Maybe<InstructorCreateInput>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionCreateManyWithoutUserInput>;
  academies?: Maybe<AcademyCreateManyWithoutUsersInput>;
  checkIns?: Maybe<CheckInCreateManyWithoutUserInput>;
}

export interface BeltPromotionCreateManyWithoutUserInput {
  create?: Maybe<
    BeltPromotionCreateWithoutUserInput[] | BeltPromotionCreateWithoutUserInput
  >;
  connect?: Maybe<
    BeltPromotionWhereUniqueInput[] | BeltPromotionWhereUniqueInput
  >;
}

export interface BeltPromotionCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<PromotionType>;
  note: String;
  date?: Maybe<DateTimeInput>;
}

export interface AcademyCreateManyWithoutUsersInput {
  create?: Maybe<
    AcademyCreateWithoutUsersInput[] | AcademyCreateWithoutUsersInput
  >;
  connect?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
}

export interface AcademyCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  title: String;
  classes?: Maybe<ClassSessionCreateManyWithoutAcademyInput>;
  classPeriods?: Maybe<ClassPeriodCreateManyWithoutAcademyInput>;
}

export interface ClassPeriodCreateManyWithoutAcademyInput {
  create?: Maybe<
    | ClassPeriodCreateWithoutAcademyInput[]
    | ClassPeriodCreateWithoutAcademyInput
  >;
  connect?: Maybe<ClassPeriodWhereUniqueInput[] | ClassPeriodWhereUniqueInput>;
}

export interface ClassPeriodCreateWithoutAcademyInput {
  id?: Maybe<ID_Input>;
  day: String;
  time?: Maybe<String>;
  title?: Maybe<String>;
  instructor?: Maybe<InstructorCreateOneInput>;
  classSessions?: Maybe<ClassSessionCreateManyWithoutClassPeriodInput>;
}

export interface ClassSessionCreateManyWithoutClassPeriodInput {
  create?: Maybe<
    | ClassSessionCreateWithoutClassPeriodInput[]
    | ClassSessionCreateWithoutClassPeriodInput
  >;
  connect?: Maybe<
    ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput
  >;
}

export interface ClassSessionCreateWithoutClassPeriodInput {
  id?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  instructor: InstructorCreateOneInput;
  academy: AcademyCreateOneWithoutClassesInput;
  techniques?: Maybe<TechniqueCreateManyInput>;
  checkIns?: Maybe<CheckInCreateManyWithoutClassSessionInput>;
}

export interface AcademyCreateOneWithoutClassesInput {
  create?: Maybe<AcademyCreateWithoutClassesInput>;
  connect?: Maybe<AcademyWhereUniqueInput>;
}

export interface AcademyCreateWithoutClassesInput {
  id?: Maybe<ID_Input>;
  title: String;
  users?: Maybe<UserCreateManyWithoutAcademiesInput>;
  classPeriods?: Maybe<ClassPeriodCreateManyWithoutAcademyInput>;
}

export interface UserCreateManyWithoutAcademiesInput {
  create?: Maybe<
    UserCreateWithoutAcademiesInput[] | UserCreateWithoutAcademiesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutAcademiesInput {
  id?: Maybe<ID_Input>;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionCreateManyWithoutUserInput>;
  checkIns?: Maybe<CheckInCreateManyWithoutUserInput>;
}

export interface CheckInCreateManyWithoutUserInput {
  create?: Maybe<
    CheckInCreateWithoutUserInput[] | CheckInCreateWithoutUserInput
  >;
  connect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
}

export interface CheckInCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  checked?: Maybe<Boolean>;
  classSession?: Maybe<ClassSessionCreateOneWithoutCheckInsInput>;
  event?: Maybe<EventCreateOneWithoutCheckInsInput>;
}

export interface ClassSessionCreateOneWithoutCheckInsInput {
  create?: Maybe<ClassSessionCreateWithoutCheckInsInput>;
  connect?: Maybe<ClassSessionWhereUniqueInput>;
}

export interface ClassSessionCreateWithoutCheckInsInput {
  id?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  instructor: InstructorCreateOneInput;
  classPeriod: ClassPeriodCreateOneWithoutClassSessionsInput;
  academy: AcademyCreateOneWithoutClassesInput;
  techniques?: Maybe<TechniqueCreateManyInput>;
}

export interface ClassPeriodCreateOneWithoutClassSessionsInput {
  create?: Maybe<ClassPeriodCreateWithoutClassSessionsInput>;
  connect?: Maybe<ClassPeriodWhereUniqueInput>;
}

export interface ClassPeriodCreateWithoutClassSessionsInput {
  id?: Maybe<ID_Input>;
  day: String;
  time?: Maybe<String>;
  title?: Maybe<String>;
  instructor?: Maybe<InstructorCreateOneInput>;
  academy: AcademyCreateOneWithoutClassPeriodsInput;
}

export interface AcademyCreateOneWithoutClassPeriodsInput {
  create?: Maybe<AcademyCreateWithoutClassPeriodsInput>;
  connect?: Maybe<AcademyWhereUniqueInput>;
}

export interface AcademyCreateWithoutClassPeriodsInput {
  id?: Maybe<ID_Input>;
  title: String;
  classes?: Maybe<ClassSessionCreateManyWithoutAcademyInput>;
  users?: Maybe<UserCreateManyWithoutAcademiesInput>;
}

export interface TechniqueCreateManyInput {
  create?: Maybe<TechniqueCreateInput[] | TechniqueCreateInput>;
  connect?: Maybe<TechniqueWhereUniqueInput[] | TechniqueWhereUniqueInput>;
}

export interface TechniqueCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  tags?: Maybe<TagCreateManyWithoutTechniqueInput>;
}

export interface TagCreateManyWithoutTechniqueInput {
  create?: Maybe<
    TagCreateWithoutTechniqueInput[] | TagCreateWithoutTechniqueInput
  >;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateWithoutTechniqueInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface EventCreateOneWithoutCheckInsInput {
  create?: Maybe<EventCreateWithoutCheckInsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutCheckInsInput {
  id?: Maybe<ID_Input>;
  title: String;
  eventImage?: Maybe<String>;
  day?: Maybe<String>;
  time?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  price?: Maybe<String>;
  location?: Maybe<String>;
  note?: Maybe<String>;
  publish?: Maybe<Boolean>;
}

export interface CheckInCreateManyWithoutClassSessionInput {
  create?: Maybe<
    | CheckInCreateWithoutClassSessionInput[]
    | CheckInCreateWithoutClassSessionInput
  >;
  connect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
}

export interface CheckInCreateWithoutClassSessionInput {
  id?: Maybe<ID_Input>;
  checked?: Maybe<Boolean>;
  user: UserCreateOneWithoutCheckInsInput;
  event?: Maybe<EventCreateOneWithoutCheckInsInput>;
}

export interface UserCreateOneWithoutCheckInsInput {
  create?: Maybe<UserCreateWithoutCheckInsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCheckInsInput {
  id?: Maybe<ID_Input>;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionCreateManyWithoutUserInput>;
  academies?: Maybe<AcademyCreateManyWithoutUsersInput>;
}

export interface AcademyUpdateInput {
  title?: Maybe<String>;
  classes?: Maybe<ClassSessionUpdateManyWithoutAcademyInput>;
  users?: Maybe<UserUpdateManyWithoutAcademiesInput>;
  classPeriods?: Maybe<ClassPeriodUpdateManyWithoutAcademyInput>;
}

export interface ClassSessionUpdateManyWithoutAcademyInput {
  create?: Maybe<
    | ClassSessionCreateWithoutAcademyInput[]
    | ClassSessionCreateWithoutAcademyInput
  >;
  delete?: Maybe<ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput>;
  connect?: Maybe<
    ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput
  >;
  set?: Maybe<ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput>;
  disconnect?: Maybe<
    ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput
  >;
  update?: Maybe<
    | ClassSessionUpdateWithWhereUniqueWithoutAcademyInput[]
    | ClassSessionUpdateWithWhereUniqueWithoutAcademyInput
  >;
  upsert?: Maybe<
    | ClassSessionUpsertWithWhereUniqueWithoutAcademyInput[]
    | ClassSessionUpsertWithWhereUniqueWithoutAcademyInput
  >;
  deleteMany?: Maybe<
    ClassSessionScalarWhereInput[] | ClassSessionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ClassSessionUpdateManyWithWhereNestedInput[]
    | ClassSessionUpdateManyWithWhereNestedInput
  >;
}

export interface ClassSessionUpdateWithWhereUniqueWithoutAcademyInput {
  where: ClassSessionWhereUniqueInput;
  data: ClassSessionUpdateWithoutAcademyDataInput;
}

export interface ClassSessionUpdateWithoutAcademyDataInput {
  date?: Maybe<DateTimeInput>;
  instructor?: Maybe<InstructorUpdateOneRequiredInput>;
  classPeriod?: Maybe<ClassPeriodUpdateOneRequiredWithoutClassSessionsInput>;
  techniques?: Maybe<TechniqueUpdateManyInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutClassSessionInput>;
}

export interface InstructorUpdateOneRequiredInput {
  create?: Maybe<InstructorCreateInput>;
  update?: Maybe<InstructorUpdateDataInput>;
  upsert?: Maybe<InstructorUpsertNestedInput>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorUpdateDataInput {
  user?: Maybe<UserUpdateOneInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionUpdateManyWithoutUserInput>;
  academies?: Maybe<AcademyUpdateManyWithoutUsersInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutUserInput>;
}

export interface BeltPromotionUpdateManyWithoutUserInput {
  create?: Maybe<
    BeltPromotionCreateWithoutUserInput[] | BeltPromotionCreateWithoutUserInput
  >;
  delete?: Maybe<
    BeltPromotionWhereUniqueInput[] | BeltPromotionWhereUniqueInput
  >;
  connect?: Maybe<
    BeltPromotionWhereUniqueInput[] | BeltPromotionWhereUniqueInput
  >;
  set?: Maybe<BeltPromotionWhereUniqueInput[] | BeltPromotionWhereUniqueInput>;
  disconnect?: Maybe<
    BeltPromotionWhereUniqueInput[] | BeltPromotionWhereUniqueInput
  >;
  update?: Maybe<
    | BeltPromotionUpdateWithWhereUniqueWithoutUserInput[]
    | BeltPromotionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | BeltPromotionUpsertWithWhereUniqueWithoutUserInput[]
    | BeltPromotionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    BeltPromotionScalarWhereInput[] | BeltPromotionScalarWhereInput
  >;
  updateMany?: Maybe<
    | BeltPromotionUpdateManyWithWhereNestedInput[]
    | BeltPromotionUpdateManyWithWhereNestedInput
  >;
}

export interface BeltPromotionUpdateWithWhereUniqueWithoutUserInput {
  where: BeltPromotionWhereUniqueInput;
  data: BeltPromotionUpdateWithoutUserDataInput;
}

export interface BeltPromotionUpdateWithoutUserDataInput {
  category?: Maybe<PromotionType>;
  note?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface BeltPromotionUpsertWithWhereUniqueWithoutUserInput {
  where: BeltPromotionWhereUniqueInput;
  update: BeltPromotionUpdateWithoutUserDataInput;
  create: BeltPromotionCreateWithoutUserInput;
}

export interface BeltPromotionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  category?: Maybe<PromotionType>;
  category_not?: Maybe<PromotionType>;
  category_in?: Maybe<PromotionType[] | PromotionType>;
  category_not_in?: Maybe<PromotionType[] | PromotionType>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updateAt?: Maybe<DateTimeInput>;
  updateAt_not?: Maybe<DateTimeInput>;
  updateAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateAt_lt?: Maybe<DateTimeInput>;
  updateAt_lte?: Maybe<DateTimeInput>;
  updateAt_gt?: Maybe<DateTimeInput>;
  updateAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BeltPromotionScalarWhereInput[] | BeltPromotionScalarWhereInput>;
  OR?: Maybe<BeltPromotionScalarWhereInput[] | BeltPromotionScalarWhereInput>;
  NOT?: Maybe<BeltPromotionScalarWhereInput[] | BeltPromotionScalarWhereInput>;
}

export interface BeltPromotionUpdateManyWithWhereNestedInput {
  where: BeltPromotionScalarWhereInput;
  data: BeltPromotionUpdateManyDataInput;
}

export interface BeltPromotionUpdateManyDataInput {
  category?: Maybe<PromotionType>;
  note?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface AcademyUpdateManyWithoutUsersInput {
  create?: Maybe<
    AcademyCreateWithoutUsersInput[] | AcademyCreateWithoutUsersInput
  >;
  delete?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  connect?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  set?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  disconnect?: Maybe<AcademyWhereUniqueInput[] | AcademyWhereUniqueInput>;
  update?: Maybe<
    | AcademyUpdateWithWhereUniqueWithoutUsersInput[]
    | AcademyUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | AcademyUpsertWithWhereUniqueWithoutUsersInput[]
    | AcademyUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
  updateMany?: Maybe<
    | AcademyUpdateManyWithWhereNestedInput[]
    | AcademyUpdateManyWithWhereNestedInput
  >;
}

export interface AcademyUpdateWithWhereUniqueWithoutUsersInput {
  where: AcademyWhereUniqueInput;
  data: AcademyUpdateWithoutUsersDataInput;
}

export interface AcademyUpdateWithoutUsersDataInput {
  title?: Maybe<String>;
  classes?: Maybe<ClassSessionUpdateManyWithoutAcademyInput>;
  classPeriods?: Maybe<ClassPeriodUpdateManyWithoutAcademyInput>;
}

export interface ClassPeriodUpdateManyWithoutAcademyInput {
  create?: Maybe<
    | ClassPeriodCreateWithoutAcademyInput[]
    | ClassPeriodCreateWithoutAcademyInput
  >;
  delete?: Maybe<ClassPeriodWhereUniqueInput[] | ClassPeriodWhereUniqueInput>;
  connect?: Maybe<ClassPeriodWhereUniqueInput[] | ClassPeriodWhereUniqueInput>;
  set?: Maybe<ClassPeriodWhereUniqueInput[] | ClassPeriodWhereUniqueInput>;
  disconnect?: Maybe<
    ClassPeriodWhereUniqueInput[] | ClassPeriodWhereUniqueInput
  >;
  update?: Maybe<
    | ClassPeriodUpdateWithWhereUniqueWithoutAcademyInput[]
    | ClassPeriodUpdateWithWhereUniqueWithoutAcademyInput
  >;
  upsert?: Maybe<
    | ClassPeriodUpsertWithWhereUniqueWithoutAcademyInput[]
    | ClassPeriodUpsertWithWhereUniqueWithoutAcademyInput
  >;
  deleteMany?: Maybe<
    ClassPeriodScalarWhereInput[] | ClassPeriodScalarWhereInput
  >;
  updateMany?: Maybe<
    | ClassPeriodUpdateManyWithWhereNestedInput[]
    | ClassPeriodUpdateManyWithWhereNestedInput
  >;
}

export interface ClassPeriodUpdateWithWhereUniqueWithoutAcademyInput {
  where: ClassPeriodWhereUniqueInput;
  data: ClassPeriodUpdateWithoutAcademyDataInput;
}

export interface ClassPeriodUpdateWithoutAcademyDataInput {
  day?: Maybe<String>;
  time?: Maybe<String>;
  title?: Maybe<String>;
  instructor?: Maybe<InstructorUpdateOneInput>;
  classSessions?: Maybe<ClassSessionUpdateManyWithoutClassPeriodInput>;
}

export interface InstructorUpdateOneInput {
  create?: Maybe<InstructorCreateInput>;
  update?: Maybe<InstructorUpdateDataInput>;
  upsert?: Maybe<InstructorUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorUpsertNestedInput {
  update: InstructorUpdateDataInput;
  create: InstructorCreateInput;
}

export interface ClassSessionUpdateManyWithoutClassPeriodInput {
  create?: Maybe<
    | ClassSessionCreateWithoutClassPeriodInput[]
    | ClassSessionCreateWithoutClassPeriodInput
  >;
  delete?: Maybe<ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput>;
  connect?: Maybe<
    ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput
  >;
  set?: Maybe<ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput>;
  disconnect?: Maybe<
    ClassSessionWhereUniqueInput[] | ClassSessionWhereUniqueInput
  >;
  update?: Maybe<
    | ClassSessionUpdateWithWhereUniqueWithoutClassPeriodInput[]
    | ClassSessionUpdateWithWhereUniqueWithoutClassPeriodInput
  >;
  upsert?: Maybe<
    | ClassSessionUpsertWithWhereUniqueWithoutClassPeriodInput[]
    | ClassSessionUpsertWithWhereUniqueWithoutClassPeriodInput
  >;
  deleteMany?: Maybe<
    ClassSessionScalarWhereInput[] | ClassSessionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ClassSessionUpdateManyWithWhereNestedInput[]
    | ClassSessionUpdateManyWithWhereNestedInput
  >;
}

export interface ClassSessionUpdateWithWhereUniqueWithoutClassPeriodInput {
  where: ClassSessionWhereUniqueInput;
  data: ClassSessionUpdateWithoutClassPeriodDataInput;
}

export interface ClassSessionUpdateWithoutClassPeriodDataInput {
  date?: Maybe<DateTimeInput>;
  instructor?: Maybe<InstructorUpdateOneRequiredInput>;
  academy?: Maybe<AcademyUpdateOneRequiredWithoutClassesInput>;
  techniques?: Maybe<TechniqueUpdateManyInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutClassSessionInput>;
}

export interface AcademyUpdateOneRequiredWithoutClassesInput {
  create?: Maybe<AcademyCreateWithoutClassesInput>;
  update?: Maybe<AcademyUpdateWithoutClassesDataInput>;
  upsert?: Maybe<AcademyUpsertWithoutClassesInput>;
  connect?: Maybe<AcademyWhereUniqueInput>;
}

export interface AcademyUpdateWithoutClassesDataInput {
  title?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutAcademiesInput>;
  classPeriods?: Maybe<ClassPeriodUpdateManyWithoutAcademyInput>;
}

export interface UserUpdateManyWithoutAcademiesInput {
  create?: Maybe<
    UserCreateWithoutAcademiesInput[] | UserCreateWithoutAcademiesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutAcademiesInput[]
    | UserUpdateWithWhereUniqueWithoutAcademiesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutAcademiesInput[]
    | UserUpsertWithWhereUniqueWithoutAcademiesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutAcademiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutAcademiesDataInput;
}

export interface UserUpdateWithoutAcademiesDataInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionUpdateManyWithoutUserInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutUserInput>;
}

export interface CheckInUpdateManyWithoutUserInput {
  create?: Maybe<
    CheckInCreateWithoutUserInput[] | CheckInCreateWithoutUserInput
  >;
  delete?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  connect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  set?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  disconnect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  update?: Maybe<
    | CheckInUpdateWithWhereUniqueWithoutUserInput[]
    | CheckInUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CheckInUpsertWithWhereUniqueWithoutUserInput[]
    | CheckInUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CheckInScalarWhereInput[] | CheckInScalarWhereInput>;
  updateMany?: Maybe<
    | CheckInUpdateManyWithWhereNestedInput[]
    | CheckInUpdateManyWithWhereNestedInput
  >;
}

export interface CheckInUpdateWithWhereUniqueWithoutUserInput {
  where: CheckInWhereUniqueInput;
  data: CheckInUpdateWithoutUserDataInput;
}

export interface CheckInUpdateWithoutUserDataInput {
  checked?: Maybe<Boolean>;
  classSession?: Maybe<ClassSessionUpdateOneWithoutCheckInsInput>;
  event?: Maybe<EventUpdateOneWithoutCheckInsInput>;
}

export interface ClassSessionUpdateOneWithoutCheckInsInput {
  create?: Maybe<ClassSessionCreateWithoutCheckInsInput>;
  update?: Maybe<ClassSessionUpdateWithoutCheckInsDataInput>;
  upsert?: Maybe<ClassSessionUpsertWithoutCheckInsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ClassSessionWhereUniqueInput>;
}

export interface ClassSessionUpdateWithoutCheckInsDataInput {
  date?: Maybe<DateTimeInput>;
  instructor?: Maybe<InstructorUpdateOneRequiredInput>;
  classPeriod?: Maybe<ClassPeriodUpdateOneRequiredWithoutClassSessionsInput>;
  academy?: Maybe<AcademyUpdateOneRequiredWithoutClassesInput>;
  techniques?: Maybe<TechniqueUpdateManyInput>;
}

export interface ClassPeriodUpdateOneRequiredWithoutClassSessionsInput {
  create?: Maybe<ClassPeriodCreateWithoutClassSessionsInput>;
  update?: Maybe<ClassPeriodUpdateWithoutClassSessionsDataInput>;
  upsert?: Maybe<ClassPeriodUpsertWithoutClassSessionsInput>;
  connect?: Maybe<ClassPeriodWhereUniqueInput>;
}

export interface ClassPeriodUpdateWithoutClassSessionsDataInput {
  day?: Maybe<String>;
  time?: Maybe<String>;
  title?: Maybe<String>;
  instructor?: Maybe<InstructorUpdateOneInput>;
  academy?: Maybe<AcademyUpdateOneRequiredWithoutClassPeriodsInput>;
}

export interface AcademyUpdateOneRequiredWithoutClassPeriodsInput {
  create?: Maybe<AcademyCreateWithoutClassPeriodsInput>;
  update?: Maybe<AcademyUpdateWithoutClassPeriodsDataInput>;
  upsert?: Maybe<AcademyUpsertWithoutClassPeriodsInput>;
  connect?: Maybe<AcademyWhereUniqueInput>;
}

export interface AcademyUpdateWithoutClassPeriodsDataInput {
  title?: Maybe<String>;
  classes?: Maybe<ClassSessionUpdateManyWithoutAcademyInput>;
  users?: Maybe<UserUpdateManyWithoutAcademiesInput>;
}

export interface AcademyUpsertWithoutClassPeriodsInput {
  update: AcademyUpdateWithoutClassPeriodsDataInput;
  create: AcademyCreateWithoutClassPeriodsInput;
}

export interface ClassPeriodUpsertWithoutClassSessionsInput {
  update: ClassPeriodUpdateWithoutClassSessionsDataInput;
  create: ClassPeriodCreateWithoutClassSessionsInput;
}

export interface TechniqueUpdateManyInput {
  create?: Maybe<TechniqueCreateInput[] | TechniqueCreateInput>;
  update?: Maybe<
    | TechniqueUpdateWithWhereUniqueNestedInput[]
    | TechniqueUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TechniqueUpsertWithWhereUniqueNestedInput[]
    | TechniqueUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TechniqueWhereUniqueInput[] | TechniqueWhereUniqueInput>;
  connect?: Maybe<TechniqueWhereUniqueInput[] | TechniqueWhereUniqueInput>;
  set?: Maybe<TechniqueWhereUniqueInput[] | TechniqueWhereUniqueInput>;
  disconnect?: Maybe<TechniqueWhereUniqueInput[] | TechniqueWhereUniqueInput>;
  deleteMany?: Maybe<TechniqueScalarWhereInput[] | TechniqueScalarWhereInput>;
  updateMany?: Maybe<
    | TechniqueUpdateManyWithWhereNestedInput[]
    | TechniqueUpdateManyWithWhereNestedInput
  >;
}

export interface TechniqueUpdateWithWhereUniqueNestedInput {
  where: TechniqueWhereUniqueInput;
  data: TechniqueUpdateDataInput;
}

export interface TechniqueUpdateDataInput {
  title?: Maybe<String>;
  tags?: Maybe<TagUpdateManyWithoutTechniqueInput>;
}

export interface TagUpdateManyWithoutTechniqueInput {
  create?: Maybe<
    TagCreateWithoutTechniqueInput[] | TagCreateWithoutTechniqueInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutTechniqueInput[]
    | TagUpdateWithWhereUniqueWithoutTechniqueInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutTechniqueInput[]
    | TagUpsertWithWhereUniqueWithoutTechniqueInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueWithoutTechniqueInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutTechniqueDataInput;
}

export interface TagUpdateWithoutTechniqueDataInput {
  name?: Maybe<String>;
}

export interface TagUpsertWithWhereUniqueWithoutTechniqueInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutTechniqueDataInput;
  create: TagCreateWithoutTechniqueInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TechniqueUpsertWithWhereUniqueNestedInput {
  where: TechniqueWhereUniqueInput;
  update: TechniqueUpdateDataInput;
  create: TechniqueCreateInput;
}

export interface TechniqueScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TechniqueScalarWhereInput[] | TechniqueScalarWhereInput>;
  OR?: Maybe<TechniqueScalarWhereInput[] | TechniqueScalarWhereInput>;
  NOT?: Maybe<TechniqueScalarWhereInput[] | TechniqueScalarWhereInput>;
}

export interface TechniqueUpdateManyWithWhereNestedInput {
  where: TechniqueScalarWhereInput;
  data: TechniqueUpdateManyDataInput;
}

export interface TechniqueUpdateManyDataInput {
  title?: Maybe<String>;
}

export interface ClassSessionUpsertWithoutCheckInsInput {
  update: ClassSessionUpdateWithoutCheckInsDataInput;
  create: ClassSessionCreateWithoutCheckInsInput;
}

export interface EventUpdateOneWithoutCheckInsInput {
  create?: Maybe<EventCreateWithoutCheckInsInput>;
  update?: Maybe<EventUpdateWithoutCheckInsDataInput>;
  upsert?: Maybe<EventUpsertWithoutCheckInsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutCheckInsDataInput {
  title?: Maybe<String>;
  eventImage?: Maybe<String>;
  day?: Maybe<String>;
  time?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  price?: Maybe<String>;
  location?: Maybe<String>;
  note?: Maybe<String>;
  publish?: Maybe<Boolean>;
}

export interface EventUpsertWithoutCheckInsInput {
  update: EventUpdateWithoutCheckInsDataInput;
  create: EventCreateWithoutCheckInsInput;
}

export interface CheckInUpsertWithWhereUniqueWithoutUserInput {
  where: CheckInWhereUniqueInput;
  update: CheckInUpdateWithoutUserDataInput;
  create: CheckInCreateWithoutUserInput;
}

export interface CheckInScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  checked?: Maybe<Boolean>;
  checked_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CheckInScalarWhereInput[] | CheckInScalarWhereInput>;
  OR?: Maybe<CheckInScalarWhereInput[] | CheckInScalarWhereInput>;
  NOT?: Maybe<CheckInScalarWhereInput[] | CheckInScalarWhereInput>;
}

export interface CheckInUpdateManyWithWhereNestedInput {
  where: CheckInScalarWhereInput;
  data: CheckInUpdateManyDataInput;
}

export interface CheckInUpdateManyDataInput {
  checked?: Maybe<Boolean>;
}

export interface UserUpsertWithWhereUniqueWithoutAcademiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutAcademiesDataInput;
  create: UserCreateWithoutAcademiesInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  dob?: Maybe<String>;
  dob_not?: Maybe<String>;
  dob_in?: Maybe<String[] | String>;
  dob_not_in?: Maybe<String[] | String>;
  dob_lt?: Maybe<String>;
  dob_lte?: Maybe<String>;
  dob_gt?: Maybe<String>;
  dob_gte?: Maybe<String>;
  dob_contains?: Maybe<String>;
  dob_not_contains?: Maybe<String>;
  dob_starts_with?: Maybe<String>;
  dob_not_starts_with?: Maybe<String>;
  dob_ends_with?: Maybe<String>;
  dob_not_ends_with?: Maybe<String>;
  joinDate?: Maybe<String>;
  joinDate_not?: Maybe<String>;
  joinDate_in?: Maybe<String[] | String>;
  joinDate_not_in?: Maybe<String[] | String>;
  joinDate_lt?: Maybe<String>;
  joinDate_lte?: Maybe<String>;
  joinDate_gt?: Maybe<String>;
  joinDate_gte?: Maybe<String>;
  joinDate_contains?: Maybe<String>;
  joinDate_not_contains?: Maybe<String>;
  joinDate_starts_with?: Maybe<String>;
  joinDate_not_starts_with?: Maybe<String>;
  joinDate_ends_with?: Maybe<String>;
  joinDate_not_ends_with?: Maybe<String>;
  position?: Maybe<PositionType>;
  position_not?: Maybe<PositionType>;
  position_in?: Maybe<PositionType[] | PositionType>;
  position_not_in?: Maybe<PositionType[] | PositionType>;
  beltColor?: Maybe<BeltColor>;
  beltColor_not?: Maybe<BeltColor>;
  beltColor_in?: Maybe<BeltColor[] | BeltColor>;
  beltColor_not_in?: Maybe<BeltColor[] | BeltColor>;
  stripeCount?: Maybe<Int>;
  stripeCount_not?: Maybe<Int>;
  stripeCount_in?: Maybe<Int[] | Int>;
  stripeCount_not_in?: Maybe<Int[] | Int>;
  stripeCount_lt?: Maybe<Int>;
  stripeCount_lte?: Maybe<Int>;
  stripeCount_gt?: Maybe<Int>;
  stripeCount_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
}

export interface AcademyUpsertWithoutClassesInput {
  update: AcademyUpdateWithoutClassesDataInput;
  create: AcademyCreateWithoutClassesInput;
}

export interface CheckInUpdateManyWithoutClassSessionInput {
  create?: Maybe<
    | CheckInCreateWithoutClassSessionInput[]
    | CheckInCreateWithoutClassSessionInput
  >;
  delete?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  connect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  set?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  disconnect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  update?: Maybe<
    | CheckInUpdateWithWhereUniqueWithoutClassSessionInput[]
    | CheckInUpdateWithWhereUniqueWithoutClassSessionInput
  >;
  upsert?: Maybe<
    | CheckInUpsertWithWhereUniqueWithoutClassSessionInput[]
    | CheckInUpsertWithWhereUniqueWithoutClassSessionInput
  >;
  deleteMany?: Maybe<CheckInScalarWhereInput[] | CheckInScalarWhereInput>;
  updateMany?: Maybe<
    | CheckInUpdateManyWithWhereNestedInput[]
    | CheckInUpdateManyWithWhereNestedInput
  >;
}

export interface CheckInUpdateWithWhereUniqueWithoutClassSessionInput {
  where: CheckInWhereUniqueInput;
  data: CheckInUpdateWithoutClassSessionDataInput;
}

export interface CheckInUpdateWithoutClassSessionDataInput {
  checked?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutCheckInsInput>;
  event?: Maybe<EventUpdateOneWithoutCheckInsInput>;
}

export interface UserUpdateOneRequiredWithoutCheckInsInput {
  create?: Maybe<UserCreateWithoutCheckInsInput>;
  update?: Maybe<UserUpdateWithoutCheckInsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCheckInsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCheckInsDataInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionUpdateManyWithoutUserInput>;
  academies?: Maybe<AcademyUpdateManyWithoutUsersInput>;
}

export interface UserUpsertWithoutCheckInsInput {
  update: UserUpdateWithoutCheckInsDataInput;
  create: UserCreateWithoutCheckInsInput;
}

export interface CheckInUpsertWithWhereUniqueWithoutClassSessionInput {
  where: CheckInWhereUniqueInput;
  update: CheckInUpdateWithoutClassSessionDataInput;
  create: CheckInCreateWithoutClassSessionInput;
}

export interface ClassSessionUpsertWithWhereUniqueWithoutClassPeriodInput {
  where: ClassSessionWhereUniqueInput;
  update: ClassSessionUpdateWithoutClassPeriodDataInput;
  create: ClassSessionCreateWithoutClassPeriodInput;
}

export interface ClassSessionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassSessionScalarWhereInput[] | ClassSessionScalarWhereInput>;
  OR?: Maybe<ClassSessionScalarWhereInput[] | ClassSessionScalarWhereInput>;
  NOT?: Maybe<ClassSessionScalarWhereInput[] | ClassSessionScalarWhereInput>;
}

export interface ClassSessionUpdateManyWithWhereNestedInput {
  where: ClassSessionScalarWhereInput;
  data: ClassSessionUpdateManyDataInput;
}

export interface ClassSessionUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
}

export interface ClassPeriodUpsertWithWhereUniqueWithoutAcademyInput {
  where: ClassPeriodWhereUniqueInput;
  update: ClassPeriodUpdateWithoutAcademyDataInput;
  create: ClassPeriodCreateWithoutAcademyInput;
}

export interface ClassPeriodScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassPeriodScalarWhereInput[] | ClassPeriodScalarWhereInput>;
  OR?: Maybe<ClassPeriodScalarWhereInput[] | ClassPeriodScalarWhereInput>;
  NOT?: Maybe<ClassPeriodScalarWhereInput[] | ClassPeriodScalarWhereInput>;
}

export interface ClassPeriodUpdateManyWithWhereNestedInput {
  where: ClassPeriodScalarWhereInput;
  data: ClassPeriodUpdateManyDataInput;
}

export interface ClassPeriodUpdateManyDataInput {
  day?: Maybe<String>;
  time?: Maybe<String>;
  title?: Maybe<String>;
}

export interface AcademyUpsertWithWhereUniqueWithoutUsersInput {
  where: AcademyWhereUniqueInput;
  update: AcademyUpdateWithoutUsersDataInput;
  create: AcademyCreateWithoutUsersInput;
}

export interface AcademyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
  OR?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
  NOT?: Maybe<AcademyScalarWhereInput[] | AcademyScalarWhereInput>;
}

export interface AcademyUpdateManyWithWhereNestedInput {
  where: AcademyScalarWhereInput;
  data: AcademyUpdateManyDataInput;
}

export interface AcademyUpdateManyDataInput {
  title?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ClassSessionUpsertWithWhereUniqueWithoutAcademyInput {
  where: ClassSessionWhereUniqueInput;
  update: ClassSessionUpdateWithoutAcademyDataInput;
  create: ClassSessionCreateWithoutAcademyInput;
}

export interface AcademyUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface BeltPromotionCreateInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<PromotionType>;
  note: String;
  date?: Maybe<DateTimeInput>;
  user: UserCreateOneWithoutBeltPromotionsInput;
}

export interface UserCreateOneWithoutBeltPromotionsInput {
  create?: Maybe<UserCreateWithoutBeltPromotionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutBeltPromotionsInput {
  id?: Maybe<ID_Input>;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  academies?: Maybe<AcademyCreateManyWithoutUsersInput>;
  checkIns?: Maybe<CheckInCreateManyWithoutUserInput>;
}

export interface BeltPromotionUpdateInput {
  category?: Maybe<PromotionType>;
  note?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutBeltPromotionsInput>;
}

export interface UserUpdateOneRequiredWithoutBeltPromotionsInput {
  create?: Maybe<UserCreateWithoutBeltPromotionsInput>;
  update?: Maybe<UserUpdateWithoutBeltPromotionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBeltPromotionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutBeltPromotionsDataInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  academies?: Maybe<AcademyUpdateManyWithoutUsersInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutBeltPromotionsInput {
  update: UserUpdateWithoutBeltPromotionsDataInput;
  create: UserCreateWithoutBeltPromotionsInput;
}

export interface BeltPromotionUpdateManyMutationInput {
  category?: Maybe<PromotionType>;
  note?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface CheckInCreateInput {
  id?: Maybe<ID_Input>;
  checked?: Maybe<Boolean>;
  user: UserCreateOneWithoutCheckInsInput;
  classSession?: Maybe<ClassSessionCreateOneWithoutCheckInsInput>;
  event?: Maybe<EventCreateOneWithoutCheckInsInput>;
}

export interface CheckInUpdateInput {
  checked?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutCheckInsInput>;
  classSession?: Maybe<ClassSessionUpdateOneWithoutCheckInsInput>;
  event?: Maybe<EventUpdateOneWithoutCheckInsInput>;
}

export interface CheckInUpdateManyMutationInput {
  checked?: Maybe<Boolean>;
}

export interface ClassPeriodCreateInput {
  id?: Maybe<ID_Input>;
  day: String;
  time?: Maybe<String>;
  title?: Maybe<String>;
  instructor?: Maybe<InstructorCreateOneInput>;
  classSessions?: Maybe<ClassSessionCreateManyWithoutClassPeriodInput>;
  academy: AcademyCreateOneWithoutClassPeriodsInput;
}

export interface ClassPeriodUpdateInput {
  day?: Maybe<String>;
  time?: Maybe<String>;
  title?: Maybe<String>;
  instructor?: Maybe<InstructorUpdateOneInput>;
  classSessions?: Maybe<ClassSessionUpdateManyWithoutClassPeriodInput>;
  academy?: Maybe<AcademyUpdateOneRequiredWithoutClassPeriodsInput>;
}

export interface ClassPeriodUpdateManyMutationInput {
  day?: Maybe<String>;
  time?: Maybe<String>;
  title?: Maybe<String>;
}

export interface ClassSessionCreateInput {
  id?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  instructor: InstructorCreateOneInput;
  classPeriod: ClassPeriodCreateOneWithoutClassSessionsInput;
  academy: AcademyCreateOneWithoutClassesInput;
  techniques?: Maybe<TechniqueCreateManyInput>;
  checkIns?: Maybe<CheckInCreateManyWithoutClassSessionInput>;
}

export interface ClassSessionUpdateInput {
  date?: Maybe<DateTimeInput>;
  instructor?: Maybe<InstructorUpdateOneRequiredInput>;
  classPeriod?: Maybe<ClassPeriodUpdateOneRequiredWithoutClassSessionsInput>;
  academy?: Maybe<AcademyUpdateOneRequiredWithoutClassesInput>;
  techniques?: Maybe<TechniqueUpdateManyInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutClassSessionInput>;
}

export interface ClassSessionUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  eventImage?: Maybe<String>;
  day?: Maybe<String>;
  time?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  price?: Maybe<String>;
  location?: Maybe<String>;
  note?: Maybe<String>;
  publish?: Maybe<Boolean>;
  checkIns?: Maybe<CheckInCreateManyWithoutEventInput>;
}

export interface CheckInCreateManyWithoutEventInput {
  create?: Maybe<
    CheckInCreateWithoutEventInput[] | CheckInCreateWithoutEventInput
  >;
  connect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
}

export interface CheckInCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  checked?: Maybe<Boolean>;
  user: UserCreateOneWithoutCheckInsInput;
  classSession?: Maybe<ClassSessionCreateOneWithoutCheckInsInput>;
}

export interface EventUpdateInput {
  title?: Maybe<String>;
  eventImage?: Maybe<String>;
  day?: Maybe<String>;
  time?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  price?: Maybe<String>;
  location?: Maybe<String>;
  note?: Maybe<String>;
  publish?: Maybe<Boolean>;
  checkIns?: Maybe<CheckInUpdateManyWithoutEventInput>;
}

export interface CheckInUpdateManyWithoutEventInput {
  create?: Maybe<
    CheckInCreateWithoutEventInput[] | CheckInCreateWithoutEventInput
  >;
  delete?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  connect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  set?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  disconnect?: Maybe<CheckInWhereUniqueInput[] | CheckInWhereUniqueInput>;
  update?: Maybe<
    | CheckInUpdateWithWhereUniqueWithoutEventInput[]
    | CheckInUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | CheckInUpsertWithWhereUniqueWithoutEventInput[]
    | CheckInUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<CheckInScalarWhereInput[] | CheckInScalarWhereInput>;
  updateMany?: Maybe<
    | CheckInUpdateManyWithWhereNestedInput[]
    | CheckInUpdateManyWithWhereNestedInput
  >;
}

export interface CheckInUpdateWithWhereUniqueWithoutEventInput {
  where: CheckInWhereUniqueInput;
  data: CheckInUpdateWithoutEventDataInput;
}

export interface CheckInUpdateWithoutEventDataInput {
  checked?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutCheckInsInput>;
  classSession?: Maybe<ClassSessionUpdateOneWithoutCheckInsInput>;
}

export interface CheckInUpsertWithWhereUniqueWithoutEventInput {
  where: CheckInWhereUniqueInput;
  update: CheckInUpdateWithoutEventDataInput;
  create: CheckInCreateWithoutEventInput;
}

export interface EventUpdateManyMutationInput {
  title?: Maybe<String>;
  eventImage?: Maybe<String>;
  day?: Maybe<String>;
  time?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<String>;
  price?: Maybe<String>;
  location?: Maybe<String>;
  note?: Maybe<String>;
  publish?: Maybe<Boolean>;
}

export interface InstructorUpdateInput {
  user?: Maybe<UserUpdateOneInput>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  technique?: Maybe<TechniqueCreateOneWithoutTagsInput>;
}

export interface TechniqueCreateOneWithoutTagsInput {
  create?: Maybe<TechniqueCreateWithoutTagsInput>;
  connect?: Maybe<TechniqueWhereUniqueInput>;
}

export interface TechniqueCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  title: String;
}

export interface TagUpdateInput {
  name?: Maybe<String>;
  technique?: Maybe<TechniqueUpdateOneWithoutTagsInput>;
}

export interface TechniqueUpdateOneWithoutTagsInput {
  create?: Maybe<TechniqueCreateWithoutTagsInput>;
  update?: Maybe<TechniqueUpdateWithoutTagsDataInput>;
  upsert?: Maybe<TechniqueUpsertWithoutTagsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TechniqueWhereUniqueInput>;
}

export interface TechniqueUpdateWithoutTagsDataInput {
  title?: Maybe<String>;
}

export interface TechniqueUpsertWithoutTagsInput {
  update: TechniqueUpdateWithoutTagsDataInput;
  create: TechniqueCreateWithoutTagsInput;
}

export interface TagUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TechniqueUpdateInput {
  title?: Maybe<String>;
  tags?: Maybe<TagUpdateManyWithoutTechniqueInput>;
}

export interface TechniqueUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface UserUpdateInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
  beltPromotions?: Maybe<BeltPromotionUpdateManyWithoutUserInput>;
  academies?: Maybe<AcademyUpdateManyWithoutUsersInput>;
  checkIns?: Maybe<CheckInUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  dob?: Maybe<String>;
  joinDate?: Maybe<String>;
  position?: Maybe<PositionType>;
  beltColor?: Maybe<BeltColor>;
  stripeCount?: Maybe<Int>;
}

export interface AcademySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AcademyWhereInput>;
  AND?: Maybe<AcademySubscriptionWhereInput[] | AcademySubscriptionWhereInput>;
  OR?: Maybe<AcademySubscriptionWhereInput[] | AcademySubscriptionWhereInput>;
  NOT?: Maybe<AcademySubscriptionWhereInput[] | AcademySubscriptionWhereInput>;
}

export interface BeltPromotionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BeltPromotionWhereInput>;
  AND?: Maybe<
    BeltPromotionSubscriptionWhereInput[] | BeltPromotionSubscriptionWhereInput
  >;
  OR?: Maybe<
    BeltPromotionSubscriptionWhereInput[] | BeltPromotionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BeltPromotionSubscriptionWhereInput[] | BeltPromotionSubscriptionWhereInput
  >;
}

export interface CheckInSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CheckInWhereInput>;
  AND?: Maybe<CheckInSubscriptionWhereInput[] | CheckInSubscriptionWhereInput>;
  OR?: Maybe<CheckInSubscriptionWhereInput[] | CheckInSubscriptionWhereInput>;
  NOT?: Maybe<CheckInSubscriptionWhereInput[] | CheckInSubscriptionWhereInput>;
}

export interface ClassPeriodSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassPeriodWhereInput>;
  AND?: Maybe<
    ClassPeriodSubscriptionWhereInput[] | ClassPeriodSubscriptionWhereInput
  >;
  OR?: Maybe<
    ClassPeriodSubscriptionWhereInput[] | ClassPeriodSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ClassPeriodSubscriptionWhereInput[] | ClassPeriodSubscriptionWhereInput
  >;
}

export interface ClassSessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassSessionWhereInput>;
  AND?: Maybe<
    ClassSessionSubscriptionWhereInput[] | ClassSessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    ClassSessionSubscriptionWhereInput[] | ClassSessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ClassSessionSubscriptionWhereInput[] | ClassSessionSubscriptionWhereInput
  >;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface InstructorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InstructorWhereInput>;
  AND?: Maybe<
    InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput
  >;
  OR?: Maybe<
    InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput
  >;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface TechniqueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TechniqueWhereInput>;
  AND?: Maybe<
    TechniqueSubscriptionWhereInput[] | TechniqueSubscriptionWhereInput
  >;
  OR?: Maybe<
    TechniqueSubscriptionWhereInput[] | TechniqueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TechniqueSubscriptionWhereInput[] | TechniqueSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Academy {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AcademyPromise extends Promise<Academy>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  classes: <T = FragmentableArray<ClassSession>>(args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classPeriods: <T = FragmentableArray<ClassPeriod>>(args?: {
    where?: ClassPeriodWhereInput;
    orderBy?: ClassPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AcademySubscription
  extends Promise<AsyncIterator<Academy>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  classes: <T = Promise<AsyncIterator<ClassSessionSubscription>>>(args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classPeriods: <T = Promise<AsyncIterator<ClassPeriodSubscription>>>(args?: {
    where?: ClassPeriodWhereInput;
    orderBy?: ClassPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AcademyNullablePromise
  extends Promise<Academy | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  classes: <T = FragmentableArray<ClassSession>>(args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classPeriods: <T = FragmentableArray<ClassPeriod>>(args?: {
    where?: ClassPeriodWhereInput;
    orderBy?: ClassPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSession {
  id: ID_Output;
  date?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassSessionPromise
  extends Promise<ClassSession>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  instructor: <T = InstructorPromise>() => T;
  classPeriod: <T = ClassPeriodPromise>() => T;
  academy: <T = AcademyPromise>() => T;
  techniques: <T = FragmentableArray<Technique>>(args?: {
    where?: TechniqueWhereInput;
    orderBy?: TechniqueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  checkIns: <T = FragmentableArray<CheckIn>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSessionSubscription
  extends Promise<AsyncIterator<ClassSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  instructor: <T = InstructorSubscription>() => T;
  classPeriod: <T = ClassPeriodSubscription>() => T;
  academy: <T = AcademySubscription>() => T;
  techniques: <T = Promise<AsyncIterator<TechniqueSubscription>>>(args?: {
    where?: TechniqueWhereInput;
    orderBy?: TechniqueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  checkIns: <T = Promise<AsyncIterator<CheckInSubscription>>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassSessionNullablePromise
  extends Promise<ClassSession | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  instructor: <T = InstructorPromise>() => T;
  classPeriod: <T = ClassPeriodPromise>() => T;
  academy: <T = AcademyPromise>() => T;
  techniques: <T = FragmentableArray<Technique>>(args?: {
    where?: TechniqueWhereInput;
    orderBy?: TechniqueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  checkIns: <T = FragmentableArray<CheckIn>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Instructor {
  id: ID_Output;
}

export interface InstructorPromise extends Promise<Instructor>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
}

export interface InstructorSubscription
  extends Promise<AsyncIterator<Instructor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface InstructorNullablePromise
  extends Promise<Instructor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  phone?: String;
  dob?: String;
  joinDate?: String;
  position?: PositionType;
  beltColor?: BeltColor;
  stripeCount?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  dob: () => Promise<String>;
  joinDate: () => Promise<String>;
  position: () => Promise<PositionType>;
  beltColor: () => Promise<BeltColor>;
  stripeCount: () => Promise<Int>;
  beltPromotions: <T = FragmentableArray<BeltPromotion>>(args?: {
    where?: BeltPromotionWhereInput;
    orderBy?: BeltPromotionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  academies: <T = FragmentableArray<Academy>>(args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  checkIns: <T = FragmentableArray<CheckIn>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<String>>;
  joinDate: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<PositionType>>;
  beltColor: () => Promise<AsyncIterator<BeltColor>>;
  stripeCount: () => Promise<AsyncIterator<Int>>;
  beltPromotions: <
    T = Promise<AsyncIterator<BeltPromotionSubscription>>
  >(args?: {
    where?: BeltPromotionWhereInput;
    orderBy?: BeltPromotionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  academies: <T = Promise<AsyncIterator<AcademySubscription>>>(args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  checkIns: <T = Promise<AsyncIterator<CheckInSubscription>>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  dob: () => Promise<String>;
  joinDate: () => Promise<String>;
  position: () => Promise<PositionType>;
  beltColor: () => Promise<BeltColor>;
  stripeCount: () => Promise<Int>;
  beltPromotions: <T = FragmentableArray<BeltPromotion>>(args?: {
    where?: BeltPromotionWhereInput;
    orderBy?: BeltPromotionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  academies: <T = FragmentableArray<Academy>>(args?: {
    where?: AcademyWhereInput;
    orderBy?: AcademyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  checkIns: <T = FragmentableArray<CheckIn>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BeltPromotion {
  id: ID_Output;
  category?: PromotionType;
  note: String;
  date?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updateAt: DateTimeOutput;
}

export interface BeltPromotionPromise
  extends Promise<BeltPromotion>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<PromotionType>;
  note: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updateAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface BeltPromotionSubscription
  extends Promise<AsyncIterator<BeltPromotion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<PromotionType>>;
  note: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updateAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
}

export interface BeltPromotionNullablePromise
  extends Promise<BeltPromotion | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<PromotionType>;
  note: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updateAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface CheckIn {
  id: ID_Output;
  checked?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CheckInPromise extends Promise<CheckIn>, Fragmentable {
  id: () => Promise<ID_Output>;
  checked: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  classSession: <T = ClassSessionPromise>() => T;
  event: <T = EventPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CheckInSubscription
  extends Promise<AsyncIterator<CheckIn>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  checked: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
  classSession: <T = ClassSessionSubscription>() => T;
  event: <T = EventSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CheckInNullablePromise
  extends Promise<CheckIn | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  checked: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  classSession: <T = ClassSessionPromise>() => T;
  event: <T = EventPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Event {
  id: ID_Output;
  title: String;
  eventImage?: String;
  day?: String;
  time?: String;
  date?: DateTimeOutput;
  type?: String;
  price?: String;
  location?: String;
  note?: String;
  publish?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  eventImage: () => Promise<String>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<String>;
  price: () => Promise<String>;
  location: () => Promise<String>;
  note: () => Promise<String>;
  publish: () => Promise<Boolean>;
  checkIns: <T = FragmentableArray<CheckIn>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  eventImage: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  publish: () => Promise<AsyncIterator<Boolean>>;
  checkIns: <T = Promise<AsyncIterator<CheckInSubscription>>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  eventImage: () => Promise<String>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<String>;
  price: () => Promise<String>;
  location: () => Promise<String>;
  note: () => Promise<String>;
  publish: () => Promise<Boolean>;
  checkIns: <T = FragmentableArray<CheckIn>>(args?: {
    where?: CheckInWhereInput;
    orderBy?: CheckInOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPeriod {
  id: ID_Output;
  day: String;
  time?: String;
  title?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPeriodPromise extends Promise<ClassPeriod>, Fragmentable {
  id: () => Promise<ID_Output>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  title: () => Promise<String>;
  instructor: <T = InstructorPromise>() => T;
  classSessions: <T = FragmentableArray<ClassSession>>(args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  academy: <T = AcademyPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPeriodSubscription
  extends Promise<AsyncIterator<ClassPeriod>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  day: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  instructor: <T = InstructorSubscription>() => T;
  classSessions: <T = Promise<AsyncIterator<ClassSessionSubscription>>>(args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  academy: <T = AcademySubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassPeriodNullablePromise
  extends Promise<ClassPeriod | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  title: () => Promise<String>;
  instructor: <T = InstructorPromise>() => T;
  classSessions: <T = FragmentableArray<ClassSession>>(args?: {
    where?: ClassSessionWhereInput;
    orderBy?: ClassSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  academy: <T = AcademyPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Technique {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TechniquePromise extends Promise<Technique>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TechniqueSubscription
  extends Promise<AsyncIterator<Technique>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TechniqueNullablePromise
  extends Promise<Technique | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Tag {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  technique: <T = TechniquePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  technique: <T = TechniqueSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  technique: <T = TechniquePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AcademyConnection {
  pageInfo: PageInfo;
  edges: AcademyEdge[];
}

export interface AcademyConnectionPromise
  extends Promise<AcademyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AcademyEdge>>() => T;
  aggregate: <T = AggregateAcademyPromise>() => T;
}

export interface AcademyConnectionSubscription
  extends Promise<AsyncIterator<AcademyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AcademyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAcademySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AcademyEdge {
  node: Academy;
  cursor: String;
}

export interface AcademyEdgePromise extends Promise<AcademyEdge>, Fragmentable {
  node: <T = AcademyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AcademyEdgeSubscription
  extends Promise<AsyncIterator<AcademyEdge>>,
    Fragmentable {
  node: <T = AcademySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAcademy {
  count: Int;
}

export interface AggregateAcademyPromise
  extends Promise<AggregateAcademy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAcademySubscription
  extends Promise<AsyncIterator<AggregateAcademy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BeltPromotionConnection {
  pageInfo: PageInfo;
  edges: BeltPromotionEdge[];
}

export interface BeltPromotionConnectionPromise
  extends Promise<BeltPromotionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BeltPromotionEdge>>() => T;
  aggregate: <T = AggregateBeltPromotionPromise>() => T;
}

export interface BeltPromotionConnectionSubscription
  extends Promise<AsyncIterator<BeltPromotionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BeltPromotionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBeltPromotionSubscription>() => T;
}

export interface BeltPromotionEdge {
  node: BeltPromotion;
  cursor: String;
}

export interface BeltPromotionEdgePromise
  extends Promise<BeltPromotionEdge>,
    Fragmentable {
  node: <T = BeltPromotionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BeltPromotionEdgeSubscription
  extends Promise<AsyncIterator<BeltPromotionEdge>>,
    Fragmentable {
  node: <T = BeltPromotionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBeltPromotion {
  count: Int;
}

export interface AggregateBeltPromotionPromise
  extends Promise<AggregateBeltPromotion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBeltPromotionSubscription
  extends Promise<AsyncIterator<AggregateBeltPromotion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CheckInConnection {
  pageInfo: PageInfo;
  edges: CheckInEdge[];
}

export interface CheckInConnectionPromise
  extends Promise<CheckInConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CheckInEdge>>() => T;
  aggregate: <T = AggregateCheckInPromise>() => T;
}

export interface CheckInConnectionSubscription
  extends Promise<AsyncIterator<CheckInConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CheckInEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCheckInSubscription>() => T;
}

export interface CheckInEdge {
  node: CheckIn;
  cursor: String;
}

export interface CheckInEdgePromise extends Promise<CheckInEdge>, Fragmentable {
  node: <T = CheckInPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CheckInEdgeSubscription
  extends Promise<AsyncIterator<CheckInEdge>>,
    Fragmentable {
  node: <T = CheckInSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheckIn {
  count: Int;
}

export interface AggregateCheckInPromise
  extends Promise<AggregateCheckIn>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCheckInSubscription
  extends Promise<AsyncIterator<AggregateCheckIn>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassPeriodConnection {
  pageInfo: PageInfo;
  edges: ClassPeriodEdge[];
}

export interface ClassPeriodConnectionPromise
  extends Promise<ClassPeriodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassPeriodEdge>>() => T;
  aggregate: <T = AggregateClassPeriodPromise>() => T;
}

export interface ClassPeriodConnectionSubscription
  extends Promise<AsyncIterator<ClassPeriodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassPeriodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassPeriodSubscription>() => T;
}

export interface ClassPeriodEdge {
  node: ClassPeriod;
  cursor: String;
}

export interface ClassPeriodEdgePromise
  extends Promise<ClassPeriodEdge>,
    Fragmentable {
  node: <T = ClassPeriodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassPeriodEdgeSubscription
  extends Promise<AsyncIterator<ClassPeriodEdge>>,
    Fragmentable {
  node: <T = ClassPeriodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClassPeriod {
  count: Int;
}

export interface AggregateClassPeriodPromise
  extends Promise<AggregateClassPeriod>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassPeriodSubscription
  extends Promise<AsyncIterator<AggregateClassPeriod>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassSessionConnection {
  pageInfo: PageInfo;
  edges: ClassSessionEdge[];
}

export interface ClassSessionConnectionPromise
  extends Promise<ClassSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassSessionEdge>>() => T;
  aggregate: <T = AggregateClassSessionPromise>() => T;
}

export interface ClassSessionConnectionSubscription
  extends Promise<AsyncIterator<ClassSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSessionSubscription>() => T;
}

export interface ClassSessionEdge {
  node: ClassSession;
  cursor: String;
}

export interface ClassSessionEdgePromise
  extends Promise<ClassSessionEdge>,
    Fragmentable {
  node: <T = ClassSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassSessionEdgeSubscription
  extends Promise<AsyncIterator<ClassSessionEdge>>,
    Fragmentable {
  node: <T = ClassSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClassSession {
  count: Int;
}

export interface AggregateClassSessionPromise
  extends Promise<AggregateClassSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSessionSubscription
  extends Promise<AsyncIterator<AggregateClassSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InstructorConnection {
  pageInfo: PageInfo;
  edges: InstructorEdge[];
}

export interface InstructorConnectionPromise
  extends Promise<InstructorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InstructorEdge>>() => T;
  aggregate: <T = AggregateInstructorPromise>() => T;
}

export interface InstructorConnectionSubscription
  extends Promise<AsyncIterator<InstructorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InstructorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInstructorSubscription>() => T;
}

export interface InstructorEdge {
  node: Instructor;
  cursor: String;
}

export interface InstructorEdgePromise
  extends Promise<InstructorEdge>,
    Fragmentable {
  node: <T = InstructorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InstructorEdgeSubscription
  extends Promise<AsyncIterator<InstructorEdge>>,
    Fragmentable {
  node: <T = InstructorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInstructor {
  count: Int;
}

export interface AggregateInstructorPromise
  extends Promise<AggregateInstructor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInstructorSubscription
  extends Promise<AsyncIterator<AggregateInstructor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TechniqueConnection {
  pageInfo: PageInfo;
  edges: TechniqueEdge[];
}

export interface TechniqueConnectionPromise
  extends Promise<TechniqueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TechniqueEdge>>() => T;
  aggregate: <T = AggregateTechniquePromise>() => T;
}

export interface TechniqueConnectionSubscription
  extends Promise<AsyncIterator<TechniqueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TechniqueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTechniqueSubscription>() => T;
}

export interface TechniqueEdge {
  node: Technique;
  cursor: String;
}

export interface TechniqueEdgePromise
  extends Promise<TechniqueEdge>,
    Fragmentable {
  node: <T = TechniquePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TechniqueEdgeSubscription
  extends Promise<AsyncIterator<TechniqueEdge>>,
    Fragmentable {
  node: <T = TechniqueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTechnique {
  count: Int;
}

export interface AggregateTechniquePromise
  extends Promise<AggregateTechnique>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTechniqueSubscription
  extends Promise<AsyncIterator<AggregateTechnique>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AcademySubscriptionPayload {
  mutation: MutationType;
  node: Academy;
  updatedFields: String[];
  previousValues: AcademyPreviousValues;
}

export interface AcademySubscriptionPayloadPromise
  extends Promise<AcademySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AcademyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AcademyPreviousValuesPromise>() => T;
}

export interface AcademySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AcademySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AcademySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AcademyPreviousValuesSubscription>() => T;
}

export interface AcademyPreviousValues {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AcademyPreviousValuesPromise
  extends Promise<AcademyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AcademyPreviousValuesSubscription
  extends Promise<AsyncIterator<AcademyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BeltPromotionSubscriptionPayload {
  mutation: MutationType;
  node: BeltPromotion;
  updatedFields: String[];
  previousValues: BeltPromotionPreviousValues;
}

export interface BeltPromotionSubscriptionPayloadPromise
  extends Promise<BeltPromotionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BeltPromotionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BeltPromotionPreviousValuesPromise>() => T;
}

export interface BeltPromotionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BeltPromotionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BeltPromotionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BeltPromotionPreviousValuesSubscription>() => T;
}

export interface BeltPromotionPreviousValues {
  id: ID_Output;
  category?: PromotionType;
  note: String;
  date?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updateAt: DateTimeOutput;
}

export interface BeltPromotionPreviousValuesPromise
  extends Promise<BeltPromotionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<PromotionType>;
  note: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updateAt: () => Promise<DateTimeOutput>;
}

export interface BeltPromotionPreviousValuesSubscription
  extends Promise<AsyncIterator<BeltPromotionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<PromotionType>>;
  note: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updateAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CheckInSubscriptionPayload {
  mutation: MutationType;
  node: CheckIn;
  updatedFields: String[];
  previousValues: CheckInPreviousValues;
}

export interface CheckInSubscriptionPayloadPromise
  extends Promise<CheckInSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CheckInPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckInPreviousValuesPromise>() => T;
}

export interface CheckInSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckInSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckInSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckInPreviousValuesSubscription>() => T;
}

export interface CheckInPreviousValues {
  id: ID_Output;
  checked?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CheckInPreviousValuesPromise
  extends Promise<CheckInPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  checked: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CheckInPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckInPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  checked: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassPeriodSubscriptionPayload {
  mutation: MutationType;
  node: ClassPeriod;
  updatedFields: String[];
  previousValues: ClassPeriodPreviousValues;
}

export interface ClassPeriodSubscriptionPayloadPromise
  extends Promise<ClassPeriodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPeriodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPeriodPreviousValuesPromise>() => T;
}

export interface ClassPeriodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassPeriodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassPeriodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPeriodPreviousValuesSubscription>() => T;
}

export interface ClassPeriodPreviousValues {
  id: ID_Output;
  day: String;
  time?: String;
  title?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPeriodPreviousValuesPromise
  extends Promise<ClassPeriodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPeriodPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPeriodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  day: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassSessionSubscriptionPayload {
  mutation: MutationType;
  node: ClassSession;
  updatedFields: String[];
  previousValues: ClassSessionPreviousValues;
}

export interface ClassSessionSubscriptionPayloadPromise
  extends Promise<ClassSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassSessionPreviousValuesPromise>() => T;
}

export interface ClassSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassSessionPreviousValuesSubscription>() => T;
}

export interface ClassSessionPreviousValues {
  id: ID_Output;
  date?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassSessionPreviousValuesPromise
  extends Promise<ClassSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  title: String;
  eventImage?: String;
  day?: String;
  time?: String;
  date?: DateTimeOutput;
  type?: String;
  price?: String;
  location?: String;
  note?: String;
  publish?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  eventImage: () => Promise<String>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<String>;
  price: () => Promise<String>;
  location: () => Promise<String>;
  note: () => Promise<String>;
  publish: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  eventImage: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  publish: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InstructorSubscriptionPayload {
  mutation: MutationType;
  node: Instructor;
  updatedFields: String[];
  previousValues: InstructorPreviousValues;
}

export interface InstructorSubscriptionPayloadPromise
  extends Promise<InstructorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InstructorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InstructorPreviousValuesPromise>() => T;
}

export interface InstructorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InstructorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InstructorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InstructorPreviousValuesSubscription>() => T;
}

export interface InstructorPreviousValues {
  id: ID_Output;
}

export interface InstructorPreviousValuesPromise
  extends Promise<InstructorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface InstructorPreviousValuesSubscription
  extends Promise<AsyncIterator<InstructorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TechniqueSubscriptionPayload {
  mutation: MutationType;
  node: Technique;
  updatedFields: String[];
  previousValues: TechniquePreviousValues;
}

export interface TechniqueSubscriptionPayloadPromise
  extends Promise<TechniqueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TechniquePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TechniquePreviousValuesPromise>() => T;
}

export interface TechniqueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TechniqueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TechniqueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TechniquePreviousValuesSubscription>() => T;
}

export interface TechniquePreviousValues {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TechniquePreviousValuesPromise
  extends Promise<TechniquePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TechniquePreviousValuesSubscription
  extends Promise<AsyncIterator<TechniquePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  phone?: String;
  dob?: String;
  joinDate?: String;
  position?: PositionType;
  beltColor?: BeltColor;
  stripeCount?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  dob: () => Promise<String>;
  joinDate: () => Promise<String>;
  position: () => Promise<PositionType>;
  beltColor: () => Promise<BeltColor>;
  stripeCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<String>>;
  joinDate: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<PositionType>>;
  beltColor: () => Promise<AsyncIterator<BeltColor>>;
  stripeCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "BeltPromotion",
    embedded: false
  },
  {
    name: "PromotionType",
    embedded: false
  },
  {
    name: "PositionType",
    embedded: false
  },
  {
    name: "BeltColor",
    embedded: false
  },
  {
    name: "ClassSession",
    embedded: false
  },
  {
    name: "ClassPeriod",
    embedded: false
  },
  {
    name: "Academy",
    embedded: false
  },
  {
    name: "Technique",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Instructor",
    embedded: false
  },
  {
    name: "CheckIn",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
