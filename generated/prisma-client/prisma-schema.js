module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Academy {
  id: ID!
  title: String!
  classes(where: ClassSessionWhereInput, orderBy: ClassSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassSession!]
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  classPeriods(where: ClassPeriodWhereInput, orderBy: ClassPeriodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassPeriod!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AcademyConnection {
  pageInfo: PageInfo!
  edges: [AcademyEdge]!
  aggregate: AggregateAcademy!
}

input AcademyCreateInput {
  id: ID
  title: String!
  classes: ClassSessionCreateManyWithoutAcademyInput
  users: UserCreateManyWithoutAcademiesInput
  classPeriods: ClassPeriodCreateManyWithoutAcademyInput
}

input AcademyCreateManyWithoutUsersInput {
  create: [AcademyCreateWithoutUsersInput!]
  connect: [AcademyWhereUniqueInput!]
}

input AcademyCreateOneWithoutClassesInput {
  create: AcademyCreateWithoutClassesInput
  connect: AcademyWhereUniqueInput
}

input AcademyCreateOneWithoutClassPeriodsInput {
  create: AcademyCreateWithoutClassPeriodsInput
  connect: AcademyWhereUniqueInput
}

input AcademyCreateWithoutClassesInput {
  id: ID
  title: String!
  users: UserCreateManyWithoutAcademiesInput
  classPeriods: ClassPeriodCreateManyWithoutAcademyInput
}

input AcademyCreateWithoutClassPeriodsInput {
  id: ID
  title: String!
  classes: ClassSessionCreateManyWithoutAcademyInput
  users: UserCreateManyWithoutAcademiesInput
}

input AcademyCreateWithoutUsersInput {
  id: ID
  title: String!
  classes: ClassSessionCreateManyWithoutAcademyInput
  classPeriods: ClassPeriodCreateManyWithoutAcademyInput
}

type AcademyEdge {
  node: Academy!
  cursor: String!
}

enum AcademyOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AcademyPreviousValues {
  id: ID!
  title: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AcademyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AcademyScalarWhereInput!]
  OR: [AcademyScalarWhereInput!]
  NOT: [AcademyScalarWhereInput!]
}

type AcademySubscriptionPayload {
  mutation: MutationType!
  node: Academy
  updatedFields: [String!]
  previousValues: AcademyPreviousValues
}

input AcademySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AcademyWhereInput
  AND: [AcademySubscriptionWhereInput!]
  OR: [AcademySubscriptionWhereInput!]
  NOT: [AcademySubscriptionWhereInput!]
}

input AcademyUpdateInput {
  title: String
  classes: ClassSessionUpdateManyWithoutAcademyInput
  users: UserUpdateManyWithoutAcademiesInput
  classPeriods: ClassPeriodUpdateManyWithoutAcademyInput
}

input AcademyUpdateManyDataInput {
  title: String
}

input AcademyUpdateManyMutationInput {
  title: String
}

input AcademyUpdateManyWithoutUsersInput {
  create: [AcademyCreateWithoutUsersInput!]
  delete: [AcademyWhereUniqueInput!]
  connect: [AcademyWhereUniqueInput!]
  set: [AcademyWhereUniqueInput!]
  disconnect: [AcademyWhereUniqueInput!]
  update: [AcademyUpdateWithWhereUniqueWithoutUsersInput!]
  upsert: [AcademyUpsertWithWhereUniqueWithoutUsersInput!]
  deleteMany: [AcademyScalarWhereInput!]
  updateMany: [AcademyUpdateManyWithWhereNestedInput!]
}

input AcademyUpdateManyWithWhereNestedInput {
  where: AcademyScalarWhereInput!
  data: AcademyUpdateManyDataInput!
}

input AcademyUpdateOneRequiredWithoutClassesInput {
  create: AcademyCreateWithoutClassesInput
  update: AcademyUpdateWithoutClassesDataInput
  upsert: AcademyUpsertWithoutClassesInput
  connect: AcademyWhereUniqueInput
}

input AcademyUpdateOneRequiredWithoutClassPeriodsInput {
  create: AcademyCreateWithoutClassPeriodsInput
  update: AcademyUpdateWithoutClassPeriodsDataInput
  upsert: AcademyUpsertWithoutClassPeriodsInput
  connect: AcademyWhereUniqueInput
}

input AcademyUpdateWithoutClassesDataInput {
  title: String
  users: UserUpdateManyWithoutAcademiesInput
  classPeriods: ClassPeriodUpdateManyWithoutAcademyInput
}

input AcademyUpdateWithoutClassPeriodsDataInput {
  title: String
  classes: ClassSessionUpdateManyWithoutAcademyInput
  users: UserUpdateManyWithoutAcademiesInput
}

input AcademyUpdateWithoutUsersDataInput {
  title: String
  classes: ClassSessionUpdateManyWithoutAcademyInput
  classPeriods: ClassPeriodUpdateManyWithoutAcademyInput
}

input AcademyUpdateWithWhereUniqueWithoutUsersInput {
  where: AcademyWhereUniqueInput!
  data: AcademyUpdateWithoutUsersDataInput!
}

input AcademyUpsertWithoutClassesInput {
  update: AcademyUpdateWithoutClassesDataInput!
  create: AcademyCreateWithoutClassesInput!
}

input AcademyUpsertWithoutClassPeriodsInput {
  update: AcademyUpdateWithoutClassPeriodsDataInput!
  create: AcademyCreateWithoutClassPeriodsInput!
}

input AcademyUpsertWithWhereUniqueWithoutUsersInput {
  where: AcademyWhereUniqueInput!
  update: AcademyUpdateWithoutUsersDataInput!
  create: AcademyCreateWithoutUsersInput!
}

input AcademyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  classes_every: ClassSessionWhereInput
  classes_some: ClassSessionWhereInput
  classes_none: ClassSessionWhereInput
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  classPeriods_every: ClassPeriodWhereInput
  classPeriods_some: ClassPeriodWhereInput
  classPeriods_none: ClassPeriodWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AcademyWhereInput!]
  OR: [AcademyWhereInput!]
  NOT: [AcademyWhereInput!]
}

input AcademyWhereUniqueInput {
  id: ID
}

type AggregateAcademy {
  count: Int!
}

type AggregateBeltPromotion {
  count: Int!
}

type AggregateCheckIn {
  count: Int!
}

type AggregateClassPeriod {
  count: Int!
}

type AggregateClassSession {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateInstructor {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateTechnique {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

enum BeltColor {
  WHITE
  BLUE
  PURPLE
  BROWN
  BLACK
}

type BeltPromotion {
  id: ID!
  category: PromotionType
  note: String!
  date: DateTime
  createdAt: DateTime!
  updateAt: DateTime!
  user: User!
}

type BeltPromotionConnection {
  pageInfo: PageInfo!
  edges: [BeltPromotionEdge]!
  aggregate: AggregateBeltPromotion!
}

input BeltPromotionCreateInput {
  id: ID
  category: PromotionType
  note: String!
  date: DateTime
  user: UserCreateOneWithoutBeltPromotionsInput!
}

input BeltPromotionCreateManyWithoutUserInput {
  create: [BeltPromotionCreateWithoutUserInput!]
  connect: [BeltPromotionWhereUniqueInput!]
}

input BeltPromotionCreateWithoutUserInput {
  id: ID
  category: PromotionType
  note: String!
  date: DateTime
}

type BeltPromotionEdge {
  node: BeltPromotion!
  cursor: String!
}

enum BeltPromotionOrderByInput {
  id_ASC
  id_DESC
  category_ASC
  category_DESC
  note_ASC
  note_DESC
  date_ASC
  date_DESC
  createdAt_ASC
  createdAt_DESC
  updateAt_ASC
  updateAt_DESC
}

type BeltPromotionPreviousValues {
  id: ID!
  category: PromotionType
  note: String!
  date: DateTime
  createdAt: DateTime!
  updateAt: DateTime!
}

input BeltPromotionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: PromotionType
  category_not: PromotionType
  category_in: [PromotionType!]
  category_not_in: [PromotionType!]
  note: String
  note_not: String
  note_in: [String!]
  note_not_in: [String!]
  note_lt: String
  note_lte: String
  note_gt: String
  note_gte: String
  note_contains: String
  note_not_contains: String
  note_starts_with: String
  note_not_starts_with: String
  note_ends_with: String
  note_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  AND: [BeltPromotionScalarWhereInput!]
  OR: [BeltPromotionScalarWhereInput!]
  NOT: [BeltPromotionScalarWhereInput!]
}

type BeltPromotionSubscriptionPayload {
  mutation: MutationType!
  node: BeltPromotion
  updatedFields: [String!]
  previousValues: BeltPromotionPreviousValues
}

input BeltPromotionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BeltPromotionWhereInput
  AND: [BeltPromotionSubscriptionWhereInput!]
  OR: [BeltPromotionSubscriptionWhereInput!]
  NOT: [BeltPromotionSubscriptionWhereInput!]
}

input BeltPromotionUpdateInput {
  category: PromotionType
  note: String
  date: DateTime
  user: UserUpdateOneRequiredWithoutBeltPromotionsInput
}

input BeltPromotionUpdateManyDataInput {
  category: PromotionType
  note: String
  date: DateTime
}

input BeltPromotionUpdateManyMutationInput {
  category: PromotionType
  note: String
  date: DateTime
}

input BeltPromotionUpdateManyWithoutUserInput {
  create: [BeltPromotionCreateWithoutUserInput!]
  delete: [BeltPromotionWhereUniqueInput!]
  connect: [BeltPromotionWhereUniqueInput!]
  set: [BeltPromotionWhereUniqueInput!]
  disconnect: [BeltPromotionWhereUniqueInput!]
  update: [BeltPromotionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [BeltPromotionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [BeltPromotionScalarWhereInput!]
  updateMany: [BeltPromotionUpdateManyWithWhereNestedInput!]
}

input BeltPromotionUpdateManyWithWhereNestedInput {
  where: BeltPromotionScalarWhereInput!
  data: BeltPromotionUpdateManyDataInput!
}

input BeltPromotionUpdateWithoutUserDataInput {
  category: PromotionType
  note: String
  date: DateTime
}

input BeltPromotionUpdateWithWhereUniqueWithoutUserInput {
  where: BeltPromotionWhereUniqueInput!
  data: BeltPromotionUpdateWithoutUserDataInput!
}

input BeltPromotionUpsertWithWhereUniqueWithoutUserInput {
  where: BeltPromotionWhereUniqueInput!
  update: BeltPromotionUpdateWithoutUserDataInput!
  create: BeltPromotionCreateWithoutUserInput!
}

input BeltPromotionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: PromotionType
  category_not: PromotionType
  category_in: [PromotionType!]
  category_not_in: [PromotionType!]
  note: String
  note_not: String
  note_in: [String!]
  note_not_in: [String!]
  note_lt: String
  note_lte: String
  note_gt: String
  note_gte: String
  note_contains: String
  note_not_contains: String
  note_starts_with: String
  note_not_starts_with: String
  note_ends_with: String
  note_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  user: UserWhereInput
  AND: [BeltPromotionWhereInput!]
  OR: [BeltPromotionWhereInput!]
  NOT: [BeltPromotionWhereInput!]
}

input BeltPromotionWhereUniqueInput {
  id: ID
}

type CheckIn {
  id: ID!
  checked: Boolean
  user: User!
  classSession: ClassSession
  event: Event
  createdAt: DateTime!
}

type CheckInConnection {
  pageInfo: PageInfo!
  edges: [CheckInEdge]!
  aggregate: AggregateCheckIn!
}

input CheckInCreateInput {
  id: ID
  checked: Boolean
  user: UserCreateOneWithoutCheckInsInput!
  classSession: ClassSessionCreateOneWithoutCheckInsInput
  event: EventCreateOneWithoutCheckInsInput
}

input CheckInCreateManyWithoutClassSessionInput {
  create: [CheckInCreateWithoutClassSessionInput!]
  connect: [CheckInWhereUniqueInput!]
}

input CheckInCreateManyWithoutEventInput {
  create: [CheckInCreateWithoutEventInput!]
  connect: [CheckInWhereUniqueInput!]
}

input CheckInCreateManyWithoutUserInput {
  create: [CheckInCreateWithoutUserInput!]
  connect: [CheckInWhereUniqueInput!]
}

input CheckInCreateWithoutClassSessionInput {
  id: ID
  checked: Boolean
  user: UserCreateOneWithoutCheckInsInput!
  event: EventCreateOneWithoutCheckInsInput
}

input CheckInCreateWithoutEventInput {
  id: ID
  checked: Boolean
  user: UserCreateOneWithoutCheckInsInput!
  classSession: ClassSessionCreateOneWithoutCheckInsInput
}

input CheckInCreateWithoutUserInput {
  id: ID
  checked: Boolean
  classSession: ClassSessionCreateOneWithoutCheckInsInput
  event: EventCreateOneWithoutCheckInsInput
}

type CheckInEdge {
  node: CheckIn!
  cursor: String!
}

enum CheckInOrderByInput {
  id_ASC
  id_DESC
  checked_ASC
  checked_DESC
  createdAt_ASC
  createdAt_DESC
}

type CheckInPreviousValues {
  id: ID!
  checked: Boolean
  createdAt: DateTime!
}

input CheckInScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  checked: Boolean
  checked_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CheckInScalarWhereInput!]
  OR: [CheckInScalarWhereInput!]
  NOT: [CheckInScalarWhereInput!]
}

type CheckInSubscriptionPayload {
  mutation: MutationType!
  node: CheckIn
  updatedFields: [String!]
  previousValues: CheckInPreviousValues
}

input CheckInSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CheckInWhereInput
  AND: [CheckInSubscriptionWhereInput!]
  OR: [CheckInSubscriptionWhereInput!]
  NOT: [CheckInSubscriptionWhereInput!]
}

input CheckInUpdateInput {
  checked: Boolean
  user: UserUpdateOneRequiredWithoutCheckInsInput
  classSession: ClassSessionUpdateOneWithoutCheckInsInput
  event: EventUpdateOneWithoutCheckInsInput
}

input CheckInUpdateManyDataInput {
  checked: Boolean
}

input CheckInUpdateManyMutationInput {
  checked: Boolean
}

input CheckInUpdateManyWithoutClassSessionInput {
  create: [CheckInCreateWithoutClassSessionInput!]
  delete: [CheckInWhereUniqueInput!]
  connect: [CheckInWhereUniqueInput!]
  set: [CheckInWhereUniqueInput!]
  disconnect: [CheckInWhereUniqueInput!]
  update: [CheckInUpdateWithWhereUniqueWithoutClassSessionInput!]
  upsert: [CheckInUpsertWithWhereUniqueWithoutClassSessionInput!]
  deleteMany: [CheckInScalarWhereInput!]
  updateMany: [CheckInUpdateManyWithWhereNestedInput!]
}

input CheckInUpdateManyWithoutEventInput {
  create: [CheckInCreateWithoutEventInput!]
  delete: [CheckInWhereUniqueInput!]
  connect: [CheckInWhereUniqueInput!]
  set: [CheckInWhereUniqueInput!]
  disconnect: [CheckInWhereUniqueInput!]
  update: [CheckInUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [CheckInUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [CheckInScalarWhereInput!]
  updateMany: [CheckInUpdateManyWithWhereNestedInput!]
}

input CheckInUpdateManyWithoutUserInput {
  create: [CheckInCreateWithoutUserInput!]
  delete: [CheckInWhereUniqueInput!]
  connect: [CheckInWhereUniqueInput!]
  set: [CheckInWhereUniqueInput!]
  disconnect: [CheckInWhereUniqueInput!]
  update: [CheckInUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [CheckInUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [CheckInScalarWhereInput!]
  updateMany: [CheckInUpdateManyWithWhereNestedInput!]
}

input CheckInUpdateManyWithWhereNestedInput {
  where: CheckInScalarWhereInput!
  data: CheckInUpdateManyDataInput!
}

input CheckInUpdateWithoutClassSessionDataInput {
  checked: Boolean
  user: UserUpdateOneRequiredWithoutCheckInsInput
  event: EventUpdateOneWithoutCheckInsInput
}

input CheckInUpdateWithoutEventDataInput {
  checked: Boolean
  user: UserUpdateOneRequiredWithoutCheckInsInput
  classSession: ClassSessionUpdateOneWithoutCheckInsInput
}

input CheckInUpdateWithoutUserDataInput {
  checked: Boolean
  classSession: ClassSessionUpdateOneWithoutCheckInsInput
  event: EventUpdateOneWithoutCheckInsInput
}

input CheckInUpdateWithWhereUniqueWithoutClassSessionInput {
  where: CheckInWhereUniqueInput!
  data: CheckInUpdateWithoutClassSessionDataInput!
}

input CheckInUpdateWithWhereUniqueWithoutEventInput {
  where: CheckInWhereUniqueInput!
  data: CheckInUpdateWithoutEventDataInput!
}

input CheckInUpdateWithWhereUniqueWithoutUserInput {
  where: CheckInWhereUniqueInput!
  data: CheckInUpdateWithoutUserDataInput!
}

input CheckInUpsertWithWhereUniqueWithoutClassSessionInput {
  where: CheckInWhereUniqueInput!
  update: CheckInUpdateWithoutClassSessionDataInput!
  create: CheckInCreateWithoutClassSessionInput!
}

input CheckInUpsertWithWhereUniqueWithoutEventInput {
  where: CheckInWhereUniqueInput!
  update: CheckInUpdateWithoutEventDataInput!
  create: CheckInCreateWithoutEventInput!
}

input CheckInUpsertWithWhereUniqueWithoutUserInput {
  where: CheckInWhereUniqueInput!
  update: CheckInUpdateWithoutUserDataInput!
  create: CheckInCreateWithoutUserInput!
}

input CheckInWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  checked: Boolean
  checked_not: Boolean
  user: UserWhereInput
  classSession: ClassSessionWhereInput
  event: EventWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CheckInWhereInput!]
  OR: [CheckInWhereInput!]
  NOT: [CheckInWhereInput!]
}

input CheckInWhereUniqueInput {
  id: ID
}

type ClassPeriod {
  id: ID!
  day: String!
  time: String
  stamp: DateTime
  title: String
  instructor: Instructor
  classSessions(where: ClassSessionWhereInput, orderBy: ClassSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassSession!]
  academy: Academy!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ClassPeriodConnection {
  pageInfo: PageInfo!
  edges: [ClassPeriodEdge]!
  aggregate: AggregateClassPeriod!
}

input ClassPeriodCreateInput {
  id: ID
  day: String!
  time: String
  stamp: DateTime
  title: String
  instructor: InstructorCreateOneInput
  classSessions: ClassSessionCreateManyWithoutClassPeriodInput
  academy: AcademyCreateOneWithoutClassPeriodsInput!
}

input ClassPeriodCreateManyWithoutAcademyInput {
  create: [ClassPeriodCreateWithoutAcademyInput!]
  connect: [ClassPeriodWhereUniqueInput!]
}

input ClassPeriodCreateOneWithoutClassSessionsInput {
  create: ClassPeriodCreateWithoutClassSessionsInput
  connect: ClassPeriodWhereUniqueInput
}

input ClassPeriodCreateWithoutAcademyInput {
  id: ID
  day: String!
  time: String
  stamp: DateTime
  title: String
  instructor: InstructorCreateOneInput
  classSessions: ClassSessionCreateManyWithoutClassPeriodInput
}

input ClassPeriodCreateWithoutClassSessionsInput {
  id: ID
  day: String!
  time: String
  stamp: DateTime
  title: String
  instructor: InstructorCreateOneInput
  academy: AcademyCreateOneWithoutClassPeriodsInput!
}

type ClassPeriodEdge {
  node: ClassPeriod!
  cursor: String!
}

enum ClassPeriodOrderByInput {
  id_ASC
  id_DESC
  day_ASC
  day_DESC
  time_ASC
  time_DESC
  stamp_ASC
  stamp_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassPeriodPreviousValues {
  id: ID!
  day: String!
  time: String
  stamp: DateTime
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ClassPeriodScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  day: String
  day_not: String
  day_in: [String!]
  day_not_in: [String!]
  day_lt: String
  day_lte: String
  day_gt: String
  day_gte: String
  day_contains: String
  day_not_contains: String
  day_starts_with: String
  day_not_starts_with: String
  day_ends_with: String
  day_not_ends_with: String
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  stamp: DateTime
  stamp_not: DateTime
  stamp_in: [DateTime!]
  stamp_not_in: [DateTime!]
  stamp_lt: DateTime
  stamp_lte: DateTime
  stamp_gt: DateTime
  stamp_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassPeriodScalarWhereInput!]
  OR: [ClassPeriodScalarWhereInput!]
  NOT: [ClassPeriodScalarWhereInput!]
}

type ClassPeriodSubscriptionPayload {
  mutation: MutationType!
  node: ClassPeriod
  updatedFields: [String!]
  previousValues: ClassPeriodPreviousValues
}

input ClassPeriodSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassPeriodWhereInput
  AND: [ClassPeriodSubscriptionWhereInput!]
  OR: [ClassPeriodSubscriptionWhereInput!]
  NOT: [ClassPeriodSubscriptionWhereInput!]
}

input ClassPeriodUpdateInput {
  day: String
  time: String
  stamp: DateTime
  title: String
  instructor: InstructorUpdateOneInput
  classSessions: ClassSessionUpdateManyWithoutClassPeriodInput
  academy: AcademyUpdateOneRequiredWithoutClassPeriodsInput
}

input ClassPeriodUpdateManyDataInput {
  day: String
  time: String
  stamp: DateTime
  title: String
}

input ClassPeriodUpdateManyMutationInput {
  day: String
  time: String
  stamp: DateTime
  title: String
}

input ClassPeriodUpdateManyWithoutAcademyInput {
  create: [ClassPeriodCreateWithoutAcademyInput!]
  delete: [ClassPeriodWhereUniqueInput!]
  connect: [ClassPeriodWhereUniqueInput!]
  set: [ClassPeriodWhereUniqueInput!]
  disconnect: [ClassPeriodWhereUniqueInput!]
  update: [ClassPeriodUpdateWithWhereUniqueWithoutAcademyInput!]
  upsert: [ClassPeriodUpsertWithWhereUniqueWithoutAcademyInput!]
  deleteMany: [ClassPeriodScalarWhereInput!]
  updateMany: [ClassPeriodUpdateManyWithWhereNestedInput!]
}

input ClassPeriodUpdateManyWithWhereNestedInput {
  where: ClassPeriodScalarWhereInput!
  data: ClassPeriodUpdateManyDataInput!
}

input ClassPeriodUpdateOneRequiredWithoutClassSessionsInput {
  create: ClassPeriodCreateWithoutClassSessionsInput
  update: ClassPeriodUpdateWithoutClassSessionsDataInput
  upsert: ClassPeriodUpsertWithoutClassSessionsInput
  connect: ClassPeriodWhereUniqueInput
}

input ClassPeriodUpdateWithoutAcademyDataInput {
  day: String
  time: String
  stamp: DateTime
  title: String
  instructor: InstructorUpdateOneInput
  classSessions: ClassSessionUpdateManyWithoutClassPeriodInput
}

input ClassPeriodUpdateWithoutClassSessionsDataInput {
  day: String
  time: String
  stamp: DateTime
  title: String
  instructor: InstructorUpdateOneInput
  academy: AcademyUpdateOneRequiredWithoutClassPeriodsInput
}

input ClassPeriodUpdateWithWhereUniqueWithoutAcademyInput {
  where: ClassPeriodWhereUniqueInput!
  data: ClassPeriodUpdateWithoutAcademyDataInput!
}

input ClassPeriodUpsertWithoutClassSessionsInput {
  update: ClassPeriodUpdateWithoutClassSessionsDataInput!
  create: ClassPeriodCreateWithoutClassSessionsInput!
}

input ClassPeriodUpsertWithWhereUniqueWithoutAcademyInput {
  where: ClassPeriodWhereUniqueInput!
  update: ClassPeriodUpdateWithoutAcademyDataInput!
  create: ClassPeriodCreateWithoutAcademyInput!
}

input ClassPeriodWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  day: String
  day_not: String
  day_in: [String!]
  day_not_in: [String!]
  day_lt: String
  day_lte: String
  day_gt: String
  day_gte: String
  day_contains: String
  day_not_contains: String
  day_starts_with: String
  day_not_starts_with: String
  day_ends_with: String
  day_not_ends_with: String
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  stamp: DateTime
  stamp_not: DateTime
  stamp_in: [DateTime!]
  stamp_not_in: [DateTime!]
  stamp_lt: DateTime
  stamp_lte: DateTime
  stamp_gt: DateTime
  stamp_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  instructor: InstructorWhereInput
  classSessions_every: ClassSessionWhereInput
  classSessions_some: ClassSessionWhereInput
  classSessions_none: ClassSessionWhereInput
  academy: AcademyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassPeriodWhereInput!]
  OR: [ClassPeriodWhereInput!]
  NOT: [ClassPeriodWhereInput!]
}

input ClassPeriodWhereUniqueInput {
  id: ID
}

type ClassSession {
  id: ID!
  title: String!
  date: String
  instructor: Instructor!
  classPeriod: ClassPeriod!
  academy: Academy!
  techniques(where: TechniqueWhereInput, orderBy: TechniqueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Technique!]
  checkIns(where: CheckInWhereInput, orderBy: CheckInOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckIn!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ClassSessionConnection {
  pageInfo: PageInfo!
  edges: [ClassSessionEdge]!
  aggregate: AggregateClassSession!
}

input ClassSessionCreateInput {
  id: ID
  title: String!
  date: String
  instructor: InstructorCreateOneInput!
  classPeriod: ClassPeriodCreateOneWithoutClassSessionsInput!
  academy: AcademyCreateOneWithoutClassesInput!
  techniques: TechniqueCreateManyInput
  checkIns: CheckInCreateManyWithoutClassSessionInput
}

input ClassSessionCreateManyWithoutAcademyInput {
  create: [ClassSessionCreateWithoutAcademyInput!]
  connect: [ClassSessionWhereUniqueInput!]
}

input ClassSessionCreateManyWithoutClassPeriodInput {
  create: [ClassSessionCreateWithoutClassPeriodInput!]
  connect: [ClassSessionWhereUniqueInput!]
}

input ClassSessionCreateOneWithoutCheckInsInput {
  create: ClassSessionCreateWithoutCheckInsInput
  connect: ClassSessionWhereUniqueInput
}

input ClassSessionCreateWithoutAcademyInput {
  id: ID
  title: String!
  date: String
  instructor: InstructorCreateOneInput!
  classPeriod: ClassPeriodCreateOneWithoutClassSessionsInput!
  techniques: TechniqueCreateManyInput
  checkIns: CheckInCreateManyWithoutClassSessionInput
}

input ClassSessionCreateWithoutCheckInsInput {
  id: ID
  title: String!
  date: String
  instructor: InstructorCreateOneInput!
  classPeriod: ClassPeriodCreateOneWithoutClassSessionsInput!
  academy: AcademyCreateOneWithoutClassesInput!
  techniques: TechniqueCreateManyInput
}

input ClassSessionCreateWithoutClassPeriodInput {
  id: ID
  title: String!
  date: String
  instructor: InstructorCreateOneInput!
  academy: AcademyCreateOneWithoutClassesInput!
  techniques: TechniqueCreateManyInput
  checkIns: CheckInCreateManyWithoutClassSessionInput
}

type ClassSessionEdge {
  node: ClassSession!
  cursor: String!
}

enum ClassSessionOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  date_ASC
  date_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassSessionPreviousValues {
  id: ID!
  title: String!
  date: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ClassSessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassSessionScalarWhereInput!]
  OR: [ClassSessionScalarWhereInput!]
  NOT: [ClassSessionScalarWhereInput!]
}

type ClassSessionSubscriptionPayload {
  mutation: MutationType!
  node: ClassSession
  updatedFields: [String!]
  previousValues: ClassSessionPreviousValues
}

input ClassSessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassSessionWhereInput
  AND: [ClassSessionSubscriptionWhereInput!]
  OR: [ClassSessionSubscriptionWhereInput!]
  NOT: [ClassSessionSubscriptionWhereInput!]
}

input ClassSessionUpdateInput {
  title: String
  date: String
  instructor: InstructorUpdateOneRequiredInput
  classPeriod: ClassPeriodUpdateOneRequiredWithoutClassSessionsInput
  academy: AcademyUpdateOneRequiredWithoutClassesInput
  techniques: TechniqueUpdateManyInput
  checkIns: CheckInUpdateManyWithoutClassSessionInput
}

input ClassSessionUpdateManyDataInput {
  title: String
  date: String
}

input ClassSessionUpdateManyMutationInput {
  title: String
  date: String
}

input ClassSessionUpdateManyWithoutAcademyInput {
  create: [ClassSessionCreateWithoutAcademyInput!]
  delete: [ClassSessionWhereUniqueInput!]
  connect: [ClassSessionWhereUniqueInput!]
  set: [ClassSessionWhereUniqueInput!]
  disconnect: [ClassSessionWhereUniqueInput!]
  update: [ClassSessionUpdateWithWhereUniqueWithoutAcademyInput!]
  upsert: [ClassSessionUpsertWithWhereUniqueWithoutAcademyInput!]
  deleteMany: [ClassSessionScalarWhereInput!]
  updateMany: [ClassSessionUpdateManyWithWhereNestedInput!]
}

input ClassSessionUpdateManyWithoutClassPeriodInput {
  create: [ClassSessionCreateWithoutClassPeriodInput!]
  delete: [ClassSessionWhereUniqueInput!]
  connect: [ClassSessionWhereUniqueInput!]
  set: [ClassSessionWhereUniqueInput!]
  disconnect: [ClassSessionWhereUniqueInput!]
  update: [ClassSessionUpdateWithWhereUniqueWithoutClassPeriodInput!]
  upsert: [ClassSessionUpsertWithWhereUniqueWithoutClassPeriodInput!]
  deleteMany: [ClassSessionScalarWhereInput!]
  updateMany: [ClassSessionUpdateManyWithWhereNestedInput!]
}

input ClassSessionUpdateManyWithWhereNestedInput {
  where: ClassSessionScalarWhereInput!
  data: ClassSessionUpdateManyDataInput!
}

input ClassSessionUpdateOneWithoutCheckInsInput {
  create: ClassSessionCreateWithoutCheckInsInput
  update: ClassSessionUpdateWithoutCheckInsDataInput
  upsert: ClassSessionUpsertWithoutCheckInsInput
  delete: Boolean
  disconnect: Boolean
  connect: ClassSessionWhereUniqueInput
}

input ClassSessionUpdateWithoutAcademyDataInput {
  title: String
  date: String
  instructor: InstructorUpdateOneRequiredInput
  classPeriod: ClassPeriodUpdateOneRequiredWithoutClassSessionsInput
  techniques: TechniqueUpdateManyInput
  checkIns: CheckInUpdateManyWithoutClassSessionInput
}

input ClassSessionUpdateWithoutCheckInsDataInput {
  title: String
  date: String
  instructor: InstructorUpdateOneRequiredInput
  classPeriod: ClassPeriodUpdateOneRequiredWithoutClassSessionsInput
  academy: AcademyUpdateOneRequiredWithoutClassesInput
  techniques: TechniqueUpdateManyInput
}

input ClassSessionUpdateWithoutClassPeriodDataInput {
  title: String
  date: String
  instructor: InstructorUpdateOneRequiredInput
  academy: AcademyUpdateOneRequiredWithoutClassesInput
  techniques: TechniqueUpdateManyInput
  checkIns: CheckInUpdateManyWithoutClassSessionInput
}

input ClassSessionUpdateWithWhereUniqueWithoutAcademyInput {
  where: ClassSessionWhereUniqueInput!
  data: ClassSessionUpdateWithoutAcademyDataInput!
}

input ClassSessionUpdateWithWhereUniqueWithoutClassPeriodInput {
  where: ClassSessionWhereUniqueInput!
  data: ClassSessionUpdateWithoutClassPeriodDataInput!
}

input ClassSessionUpsertWithoutCheckInsInput {
  update: ClassSessionUpdateWithoutCheckInsDataInput!
  create: ClassSessionCreateWithoutCheckInsInput!
}

input ClassSessionUpsertWithWhereUniqueWithoutAcademyInput {
  where: ClassSessionWhereUniqueInput!
  update: ClassSessionUpdateWithoutAcademyDataInput!
  create: ClassSessionCreateWithoutAcademyInput!
}

input ClassSessionUpsertWithWhereUniqueWithoutClassPeriodInput {
  where: ClassSessionWhereUniqueInput!
  update: ClassSessionUpdateWithoutClassPeriodDataInput!
  create: ClassSessionCreateWithoutClassPeriodInput!
}

input ClassSessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  instructor: InstructorWhereInput
  classPeriod: ClassPeriodWhereInput
  academy: AcademyWhereInput
  techniques_every: TechniqueWhereInput
  techniques_some: TechniqueWhereInput
  techniques_none: TechniqueWhereInput
  checkIns_every: CheckInWhereInput
  checkIns_some: CheckInWhereInput
  checkIns_none: CheckInWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassSessionWhereInput!]
  OR: [ClassSessionWhereInput!]
  NOT: [ClassSessionWhereInput!]
}

input ClassSessionWhereUniqueInput {
  id: ID
  title: String
}

scalar DateTime

type Event {
  id: ID!
  title: String!
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
  checkIns(where: CheckInWhereInput, orderBy: CheckInOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckIn!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  id: ID
  title: String!
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
  checkIns: CheckInCreateManyWithoutEventInput
}

input EventCreateOneWithoutCheckInsInput {
  create: EventCreateWithoutCheckInsInput
  connect: EventWhereUniqueInput
}

input EventCreateWithoutCheckInsInput {
  id: ID
  title: String!
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  eventImage_ASC
  eventImage_DESC
  day_ASC
  day_DESC
  time_ASC
  time_DESC
  date_ASC
  date_DESC
  type_ASC
  type_DESC
  price_ASC
  price_DESC
  location_ASC
  location_DESC
  note_ASC
  note_DESC
  publish_ASC
  publish_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EventPreviousValues {
  id: ID!
  title: String!
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

input EventUpdateInput {
  title: String
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
  checkIns: CheckInUpdateManyWithoutEventInput
}

input EventUpdateManyMutationInput {
  title: String
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
}

input EventUpdateOneWithoutCheckInsInput {
  create: EventCreateWithoutCheckInsInput
  update: EventUpdateWithoutCheckInsDataInput
  upsert: EventUpsertWithoutCheckInsInput
  delete: Boolean
  disconnect: Boolean
  connect: EventWhereUniqueInput
}

input EventUpdateWithoutCheckInsDataInput {
  title: String
  eventImage: String
  day: String
  time: String
  date: DateTime
  type: String
  price: String
  location: String
  note: String
  publish: Boolean
}

input EventUpsertWithoutCheckInsInput {
  update: EventUpdateWithoutCheckInsDataInput!
  create: EventCreateWithoutCheckInsInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  eventImage: String
  eventImage_not: String
  eventImage_in: [String!]
  eventImage_not_in: [String!]
  eventImage_lt: String
  eventImage_lte: String
  eventImage_gt: String
  eventImage_gte: String
  eventImage_contains: String
  eventImage_not_contains: String
  eventImage_starts_with: String
  eventImage_not_starts_with: String
  eventImage_ends_with: String
  eventImage_not_ends_with: String
  day: String
  day_not: String
  day_in: [String!]
  day_not_in: [String!]
  day_lt: String
  day_lte: String
  day_gt: String
  day_gte: String
  day_contains: String
  day_not_contains: String
  day_starts_with: String
  day_not_starts_with: String
  day_ends_with: String
  day_not_ends_with: String
  time: String
  time_not: String
  time_in: [String!]
  time_not_in: [String!]
  time_lt: String
  time_lte: String
  time_gt: String
  time_gte: String
  time_contains: String
  time_not_contains: String
  time_starts_with: String
  time_not_starts_with: String
  time_ends_with: String
  time_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  price: String
  price_not: String
  price_in: [String!]
  price_not_in: [String!]
  price_lt: String
  price_lte: String
  price_gt: String
  price_gte: String
  price_contains: String
  price_not_contains: String
  price_starts_with: String
  price_not_starts_with: String
  price_ends_with: String
  price_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  note: String
  note_not: String
  note_in: [String!]
  note_not_in: [String!]
  note_lt: String
  note_lte: String
  note_gt: String
  note_gte: String
  note_contains: String
  note_not_contains: String
  note_starts_with: String
  note_not_starts_with: String
  note_ends_with: String
  note_not_ends_with: String
  publish: Boolean
  publish_not: Boolean
  checkIns_every: CheckInWhereInput
  checkIns_some: CheckInWhereInput
  checkIns_none: CheckInWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type Instructor {
  id: ID!
  user: User
}

type InstructorConnection {
  pageInfo: PageInfo!
  edges: [InstructorEdge]!
  aggregate: AggregateInstructor!
}

input InstructorCreateInput {
  id: ID
  user: UserCreateOneInput
}

input InstructorCreateOneInput {
  create: InstructorCreateInput
  connect: InstructorWhereUniqueInput
}

type InstructorEdge {
  node: Instructor!
  cursor: String!
}

enum InstructorOrderByInput {
  id_ASC
  id_DESC
}

type InstructorPreviousValues {
  id: ID!
}

type InstructorSubscriptionPayload {
  mutation: MutationType!
  node: Instructor
  updatedFields: [String!]
  previousValues: InstructorPreviousValues
}

input InstructorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InstructorWhereInput
  AND: [InstructorSubscriptionWhereInput!]
  OR: [InstructorSubscriptionWhereInput!]
  NOT: [InstructorSubscriptionWhereInput!]
}

input InstructorUpdateDataInput {
  user: UserUpdateOneInput
}

input InstructorUpdateInput {
  user: UserUpdateOneInput
}

input InstructorUpdateOneInput {
  create: InstructorCreateInput
  update: InstructorUpdateDataInput
  upsert: InstructorUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: InstructorWhereUniqueInput
}

input InstructorUpdateOneRequiredInput {
  create: InstructorCreateInput
  update: InstructorUpdateDataInput
  upsert: InstructorUpsertNestedInput
  connect: InstructorWhereUniqueInput
}

input InstructorUpsertNestedInput {
  update: InstructorUpdateDataInput!
  create: InstructorCreateInput!
}

input InstructorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  AND: [InstructorWhereInput!]
  OR: [InstructorWhereInput!]
  NOT: [InstructorWhereInput!]
}

input InstructorWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAcademy(data: AcademyCreateInput!): Academy!
  updateAcademy(data: AcademyUpdateInput!, where: AcademyWhereUniqueInput!): Academy
  updateManyAcademies(data: AcademyUpdateManyMutationInput!, where: AcademyWhereInput): BatchPayload!
  upsertAcademy(where: AcademyWhereUniqueInput!, create: AcademyCreateInput!, update: AcademyUpdateInput!): Academy!
  deleteAcademy(where: AcademyWhereUniqueInput!): Academy
  deleteManyAcademies(where: AcademyWhereInput): BatchPayload!
  createBeltPromotion(data: BeltPromotionCreateInput!): BeltPromotion!
  updateBeltPromotion(data: BeltPromotionUpdateInput!, where: BeltPromotionWhereUniqueInput!): BeltPromotion
  updateManyBeltPromotions(data: BeltPromotionUpdateManyMutationInput!, where: BeltPromotionWhereInput): BatchPayload!
  upsertBeltPromotion(where: BeltPromotionWhereUniqueInput!, create: BeltPromotionCreateInput!, update: BeltPromotionUpdateInput!): BeltPromotion!
  deleteBeltPromotion(where: BeltPromotionWhereUniqueInput!): BeltPromotion
  deleteManyBeltPromotions(where: BeltPromotionWhereInput): BatchPayload!
  createCheckIn(data: CheckInCreateInput!): CheckIn!
  updateCheckIn(data: CheckInUpdateInput!, where: CheckInWhereUniqueInput!): CheckIn
  updateManyCheckIns(data: CheckInUpdateManyMutationInput!, where: CheckInWhereInput): BatchPayload!
  upsertCheckIn(where: CheckInWhereUniqueInput!, create: CheckInCreateInput!, update: CheckInUpdateInput!): CheckIn!
  deleteCheckIn(where: CheckInWhereUniqueInput!): CheckIn
  deleteManyCheckIns(where: CheckInWhereInput): BatchPayload!
  createClassPeriod(data: ClassPeriodCreateInput!): ClassPeriod!
  updateClassPeriod(data: ClassPeriodUpdateInput!, where: ClassPeriodWhereUniqueInput!): ClassPeriod
  updateManyClassPeriods(data: ClassPeriodUpdateManyMutationInput!, where: ClassPeriodWhereInput): BatchPayload!
  upsertClassPeriod(where: ClassPeriodWhereUniqueInput!, create: ClassPeriodCreateInput!, update: ClassPeriodUpdateInput!): ClassPeriod!
  deleteClassPeriod(where: ClassPeriodWhereUniqueInput!): ClassPeriod
  deleteManyClassPeriods(where: ClassPeriodWhereInput): BatchPayload!
  createClassSession(data: ClassSessionCreateInput!): ClassSession!
  updateClassSession(data: ClassSessionUpdateInput!, where: ClassSessionWhereUniqueInput!): ClassSession
  updateManyClassSessions(data: ClassSessionUpdateManyMutationInput!, where: ClassSessionWhereInput): BatchPayload!
  upsertClassSession(where: ClassSessionWhereUniqueInput!, create: ClassSessionCreateInput!, update: ClassSessionUpdateInput!): ClassSession!
  deleteClassSession(where: ClassSessionWhereUniqueInput!): ClassSession
  deleteManyClassSessions(where: ClassSessionWhereInput): BatchPayload!
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createInstructor(data: InstructorCreateInput!): Instructor!
  updateInstructor(data: InstructorUpdateInput!, where: InstructorWhereUniqueInput!): Instructor
  upsertInstructor(where: InstructorWhereUniqueInput!, create: InstructorCreateInput!, update: InstructorUpdateInput!): Instructor!
  deleteInstructor(where: InstructorWhereUniqueInput!): Instructor
  deleteManyInstructors(where: InstructorWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createTechnique(data: TechniqueCreateInput!): Technique!
  updateTechnique(data: TechniqueUpdateInput!, where: TechniqueWhereUniqueInput!): Technique
  updateManyTechniques(data: TechniqueUpdateManyMutationInput!, where: TechniqueWhereInput): BatchPayload!
  upsertTechnique(where: TechniqueWhereUniqueInput!, create: TechniqueCreateInput!, update: TechniqueUpdateInput!): Technique!
  deleteTechnique(where: TechniqueWhereUniqueInput!): Technique
  deleteManyTechniques(where: TechniqueWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum PositionType {
  STUDENT
  INSTRUCTOR
  ADMIN
}

enum PromotionType {
  BELT
  STRIPE
}

type Query {
  academy(where: AcademyWhereUniqueInput!): Academy
  academies(where: AcademyWhereInput, orderBy: AcademyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Academy]!
  academiesConnection(where: AcademyWhereInput, orderBy: AcademyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AcademyConnection!
  beltPromotion(where: BeltPromotionWhereUniqueInput!): BeltPromotion
  beltPromotions(where: BeltPromotionWhereInput, orderBy: BeltPromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BeltPromotion]!
  beltPromotionsConnection(where: BeltPromotionWhereInput, orderBy: BeltPromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BeltPromotionConnection!
  checkIn(where: CheckInWhereUniqueInput!): CheckIn
  checkIns(where: CheckInWhereInput, orderBy: CheckInOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckIn]!
  checkInsConnection(where: CheckInWhereInput, orderBy: CheckInOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CheckInConnection!
  classPeriod(where: ClassPeriodWhereUniqueInput!): ClassPeriod
  classPeriods(where: ClassPeriodWhereInput, orderBy: ClassPeriodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassPeriod]!
  classPeriodsConnection(where: ClassPeriodWhereInput, orderBy: ClassPeriodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassPeriodConnection!
  classSession(where: ClassSessionWhereUniqueInput!): ClassSession
  classSessions(where: ClassSessionWhereInput, orderBy: ClassSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassSession]!
  classSessionsConnection(where: ClassSessionWhereInput, orderBy: ClassSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassSessionConnection!
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  instructor(where: InstructorWhereUniqueInput!): Instructor
  instructors(where: InstructorWhereInput, orderBy: InstructorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Instructor]!
  instructorsConnection(where: InstructorWhereInput, orderBy: InstructorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InstructorConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  technique(where: TechniqueWhereUniqueInput!): Technique
  techniques(where: TechniqueWhereInput, orderBy: TechniqueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Technique]!
  techniquesConnection(where: TechniqueWhereInput, orderBy: TechniqueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TechniqueConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  academy(where: AcademySubscriptionWhereInput): AcademySubscriptionPayload
  beltPromotion(where: BeltPromotionSubscriptionWhereInput): BeltPromotionSubscriptionPayload
  checkIn(where: CheckInSubscriptionWhereInput): CheckInSubscriptionPayload
  classPeriod(where: ClassPeriodSubscriptionWhereInput): ClassPeriodSubscriptionPayload
  classSession(where: ClassSessionSubscriptionWhereInput): ClassSessionSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  instructor(where: InstructorSubscriptionWhereInput): InstructorSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  technique(where: TechniqueSubscriptionWhereInput): TechniqueSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tag {
  id: ID!
  name: String!
  technique: Technique
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  name: String!
  technique: TechniqueCreateOneWithoutTagsInput
}

input TagCreateManyWithoutTechniqueInput {
  create: [TagCreateWithoutTechniqueInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateWithoutTechniqueInput {
  id: ID
  name: String!
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateInput {
  name: String
  technique: TechniqueUpdateOneWithoutTagsInput
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithoutTechniqueInput {
  create: [TagCreateWithoutTechniqueInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutTechniqueInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutTechniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithoutTechniqueDataInput {
  name: String
}

input TagUpdateWithWhereUniqueWithoutTechniqueInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutTechniqueDataInput!
}

input TagUpsertWithWhereUniqueWithoutTechniqueInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutTechniqueDataInput!
  create: TagCreateWithoutTechniqueInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  technique: TechniqueWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type Technique {
  id: ID!
  title: String!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechniqueConnection {
  pageInfo: PageInfo!
  edges: [TechniqueEdge]!
  aggregate: AggregateTechnique!
}

input TechniqueCreateInput {
  id: ID
  title: String!
  tags: TagCreateManyWithoutTechniqueInput
}

input TechniqueCreateManyInput {
  create: [TechniqueCreateInput!]
  connect: [TechniqueWhereUniqueInput!]
}

input TechniqueCreateOneWithoutTagsInput {
  create: TechniqueCreateWithoutTagsInput
  connect: TechniqueWhereUniqueInput
}

input TechniqueCreateWithoutTagsInput {
  id: ID
  title: String!
}

type TechniqueEdge {
  node: Technique!
  cursor: String!
}

enum TechniqueOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TechniquePreviousValues {
  id: ID!
  title: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TechniqueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TechniqueScalarWhereInput!]
  OR: [TechniqueScalarWhereInput!]
  NOT: [TechniqueScalarWhereInput!]
}

type TechniqueSubscriptionPayload {
  mutation: MutationType!
  node: Technique
  updatedFields: [String!]
  previousValues: TechniquePreviousValues
}

input TechniqueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TechniqueWhereInput
  AND: [TechniqueSubscriptionWhereInput!]
  OR: [TechniqueSubscriptionWhereInput!]
  NOT: [TechniqueSubscriptionWhereInput!]
}

input TechniqueUpdateDataInput {
  title: String
  tags: TagUpdateManyWithoutTechniqueInput
}

input TechniqueUpdateInput {
  title: String
  tags: TagUpdateManyWithoutTechniqueInput
}

input TechniqueUpdateManyDataInput {
  title: String
}

input TechniqueUpdateManyInput {
  create: [TechniqueCreateInput!]
  update: [TechniqueUpdateWithWhereUniqueNestedInput!]
  upsert: [TechniqueUpsertWithWhereUniqueNestedInput!]
  delete: [TechniqueWhereUniqueInput!]
  connect: [TechniqueWhereUniqueInput!]
  set: [TechniqueWhereUniqueInput!]
  disconnect: [TechniqueWhereUniqueInput!]
  deleteMany: [TechniqueScalarWhereInput!]
  updateMany: [TechniqueUpdateManyWithWhereNestedInput!]
}

input TechniqueUpdateManyMutationInput {
  title: String
}

input TechniqueUpdateManyWithWhereNestedInput {
  where: TechniqueScalarWhereInput!
  data: TechniqueUpdateManyDataInput!
}

input TechniqueUpdateOneWithoutTagsInput {
  create: TechniqueCreateWithoutTagsInput
  update: TechniqueUpdateWithoutTagsDataInput
  upsert: TechniqueUpsertWithoutTagsInput
  delete: Boolean
  disconnect: Boolean
  connect: TechniqueWhereUniqueInput
}

input TechniqueUpdateWithoutTagsDataInput {
  title: String
}

input TechniqueUpdateWithWhereUniqueNestedInput {
  where: TechniqueWhereUniqueInput!
  data: TechniqueUpdateDataInput!
}

input TechniqueUpsertWithoutTagsInput {
  update: TechniqueUpdateWithoutTagsDataInput!
  create: TechniqueCreateWithoutTagsInput!
}

input TechniqueUpsertWithWhereUniqueNestedInput {
  where: TechniqueWhereUniqueInput!
  update: TechniqueUpdateDataInput!
  create: TechniqueCreateInput!
}

input TechniqueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TechniqueWhereInput!]
  OR: [TechniqueWhereInput!]
  NOT: [TechniqueWhereInput!]
}

input TechniqueWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  password: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions(where: BeltPromotionWhereInput, orderBy: BeltPromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BeltPromotion!]
  academies(where: AcademyWhereInput, orderBy: AcademyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Academy!]
  checkIns(where: CheckInWhereInput, orderBy: CheckInOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckIn!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  password: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionCreateManyWithoutUserInput
  academies: AcademyCreateManyWithoutUsersInput
  checkIns: CheckInCreateManyWithoutUserInput
}

input UserCreateManyWithoutAcademiesInput {
  create: [UserCreateWithoutAcademiesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBeltPromotionsInput {
  create: UserCreateWithoutBeltPromotionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCheckInsInput {
  create: UserCreateWithoutCheckInsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAcademiesInput {
  id: ID
  password: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionCreateManyWithoutUserInput
  checkIns: CheckInCreateManyWithoutUserInput
}

input UserCreateWithoutBeltPromotionsInput {
  id: ID
  password: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  academies: AcademyCreateManyWithoutUsersInput
  checkIns: CheckInCreateManyWithoutUserInput
}

input UserCreateWithoutCheckInsInput {
  id: ID
  password: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionCreateManyWithoutUserInput
  academies: AcademyCreateManyWithoutUsersInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  password_ASC
  password_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  dob_ASC
  dob_DESC
  joinDate_ASC
  joinDate_DESC
  position_ASC
  position_DESC
  beltColor_ASC
  beltColor_DESC
  stripeCount_ASC
  stripeCount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  password: String!
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  dob: String
  dob_not: String
  dob_in: [String!]
  dob_not_in: [String!]
  dob_lt: String
  dob_lte: String
  dob_gt: String
  dob_gte: String
  dob_contains: String
  dob_not_contains: String
  dob_starts_with: String
  dob_not_starts_with: String
  dob_ends_with: String
  dob_not_ends_with: String
  joinDate: String
  joinDate_not: String
  joinDate_in: [String!]
  joinDate_not_in: [String!]
  joinDate_lt: String
  joinDate_lte: String
  joinDate_gt: String
  joinDate_gte: String
  joinDate_contains: String
  joinDate_not_contains: String
  joinDate_starts_with: String
  joinDate_not_starts_with: String
  joinDate_ends_with: String
  joinDate_not_ends_with: String
  position: PositionType
  position_not: PositionType
  position_in: [PositionType!]
  position_not_in: [PositionType!]
  beltColor: BeltColor
  beltColor_not: BeltColor
  beltColor_in: [BeltColor!]
  beltColor_not_in: [BeltColor!]
  stripeCount: Int
  stripeCount_not: Int
  stripeCount_in: [Int!]
  stripeCount_not_in: [Int!]
  stripeCount_lt: Int
  stripeCount_lte: Int
  stripeCount_gt: Int
  stripeCount_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionUpdateManyWithoutUserInput
  academies: AcademyUpdateManyWithoutUsersInput
  checkIns: CheckInUpdateManyWithoutUserInput
}

input UserUpdateInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionUpdateManyWithoutUserInput
  academies: AcademyUpdateManyWithoutUsersInput
  checkIns: CheckInUpdateManyWithoutUserInput
}

input UserUpdateManyDataInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
}

input UserUpdateManyMutationInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
}

input UserUpdateManyWithoutAcademiesInput {
  create: [UserCreateWithoutAcademiesInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutAcademiesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutAcademiesInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBeltPromotionsInput {
  create: UserCreateWithoutBeltPromotionsInput
  update: UserUpdateWithoutBeltPromotionsDataInput
  upsert: UserUpsertWithoutBeltPromotionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCheckInsInput {
  create: UserCreateWithoutCheckInsInput
  update: UserUpdateWithoutCheckInsDataInput
  upsert: UserUpsertWithoutCheckInsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAcademiesDataInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionUpdateManyWithoutUserInput
  checkIns: CheckInUpdateManyWithoutUserInput
}

input UserUpdateWithoutBeltPromotionsDataInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  academies: AcademyUpdateManyWithoutUsersInput
  checkIns: CheckInUpdateManyWithoutUserInput
}

input UserUpdateWithoutCheckInsDataInput {
  password: String
  firstName: String
  lastName: String
  email: String
  phone: String
  dob: String
  joinDate: String
  position: PositionType
  beltColor: BeltColor
  stripeCount: Int
  beltPromotions: BeltPromotionUpdateManyWithoutUserInput
  academies: AcademyUpdateManyWithoutUsersInput
}

input UserUpdateWithWhereUniqueWithoutAcademiesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutAcademiesDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutBeltPromotionsInput {
  update: UserUpdateWithoutBeltPromotionsDataInput!
  create: UserCreateWithoutBeltPromotionsInput!
}

input UserUpsertWithoutCheckInsInput {
  update: UserUpdateWithoutCheckInsDataInput!
  create: UserCreateWithoutCheckInsInput!
}

input UserUpsertWithWhereUniqueWithoutAcademiesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutAcademiesDataInput!
  create: UserCreateWithoutAcademiesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  dob: String
  dob_not: String
  dob_in: [String!]
  dob_not_in: [String!]
  dob_lt: String
  dob_lte: String
  dob_gt: String
  dob_gte: String
  dob_contains: String
  dob_not_contains: String
  dob_starts_with: String
  dob_not_starts_with: String
  dob_ends_with: String
  dob_not_ends_with: String
  joinDate: String
  joinDate_not: String
  joinDate_in: [String!]
  joinDate_not_in: [String!]
  joinDate_lt: String
  joinDate_lte: String
  joinDate_gt: String
  joinDate_gte: String
  joinDate_contains: String
  joinDate_not_contains: String
  joinDate_starts_with: String
  joinDate_not_starts_with: String
  joinDate_ends_with: String
  joinDate_not_ends_with: String
  position: PositionType
  position_not: PositionType
  position_in: [PositionType!]
  position_not_in: [PositionType!]
  beltColor: BeltColor
  beltColor_not: BeltColor
  beltColor_in: [BeltColor!]
  beltColor_not_in: [BeltColor!]
  stripeCount: Int
  stripeCount_not: Int
  stripeCount_in: [Int!]
  stripeCount_not_in: [Int!]
  stripeCount_lt: Int
  stripeCount_lte: Int
  stripeCount_gt: Int
  stripeCount_gte: Int
  beltPromotions_every: BeltPromotionWhereInput
  beltPromotions_some: BeltPromotionWhereInput
  beltPromotions_none: BeltPromotionWhereInput
  academies_every: AcademyWhereInput
  academies_some: AcademyWhereInput
  academies_none: AcademyWhereInput
  checkIns_every: CheckInWhereInput
  checkIns_some: CheckInWhereInput
  checkIns_none: CheckInWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    